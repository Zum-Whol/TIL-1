
## 객체 지향 프로그래밍 관련 개념 설명

- 객체의 필요성
  - 객체 : 변수와 메소드를 그루핑 한 단위
  - 연관된 것 그루핑 : 연관된 변수와 메소드는 같은 객체에 담고, 연관성이 없다면 다른 객체에 담기
  - 객체를 다른 곳에 사용하여 재사용성 높일 수 있음
  - 좋은 부품을 만드는 것이 목적

- 추상화 (abstract)
  - 현실은 소프트웨어보다 복잡함
  - 추상화 : 현실에서 필요한 부분만 현실에서 추출해서 단순화 시키는 것
  - 예시 : 지하철노선도는 실제 지도와는 다르게 지하철 타는데 필요한 정보만 단순화
  - 해결해야하는 문제를 소프트웨어상에서 단순화시킴

- 부품화
  - 부품화 : 로직이 재활용 가능하도록 하여 재사용성 높이는 것 
  - 부품화가 안 되어있으면 부분이 고장났을 때 전체를 교체해야 함
  - 메소드도 부품화된 특성 (중복적으로 자주 사용되는 것을 따로 정의해서 재활용성 높인 것)

- 은닉화(Information Hiding), 캡슐화(Encapsulation)
  - 내부 동작 방법을 단단한 케이스(객체) 안에 숨기고, 사용자에게는 부품의 사용방법만 노출
  - 객체를 모르고도 객체 사용할 수 있게 함

- 인터페이스
  - 장치와 장치의 연결점 접점으로 부품들 간의 약속
  - 규격화된 부품과 부품을 서로 교환할 수 있음 (본체에 어떤 모니터를 꽂아도 작동 가능)

## 생성자(Constructor)와 New

### 1. 객체 생성 방법
- 자바스크립트는 프로토타입 기반 프로그램에 속함 (기존 객체 지향 패러다임과는 상이할 수 있음)
- 프로퍼티(Property) : 객체에 담겨있는 변수 값
- 메소드(Method) : 객체에 담겨있는 함수 값. 함수가 객체에 속해 있으면 메소드로 지칭
```js
let MyMath = {
    floor : function(val){
        return Math.floor(val);
    }
}

MyMath.floor(3.9)    // 3
```

- 객체 만드는 2가지 방법 예시 (2번째 방법이 직관적)
```js
let person = {}
person.name = 'egoing';
person.introdue = function() {
    return `my name is `+this.name;  // this는 person 객체를 뜻함
}
```
```js
let person = {
    'name': 'egoing',
    'introduce': function() {
        return `My name is `+this.name;
    }
}
```

### 2. 생성자(Constructor)
- 생성자 : 객체를 만드는 역할. 객체에 대한 초기화를 함
- new : 함수 앞에 new를 붙이면, 그 함수는 객체를 만드는 생성자 함수가 됨 

```js
function Person(name) {
    this.name = name;
    this.introduce = function() {
        return 'My name is ' + this.name;
    }
}

let p1 = new Person ('Jacob');
console.log(p1) // Person {name: "Jacob", introduce: f}
p1.introduce()  // "My name is Jacob"

let p2 = new Person ('Jiyun');
console.log(p2) // Person {name: "Jiyun", introduce: f}
p1.introduce()  // 'My name is Jiyun'
```

```js
function Person() {
    this.name='kim';
    this.first=10;
    this.second=20;
    this.third=30;
    this.sum = function(){
        return this.first + this.second + this.third;
    }
}

console.log(Person())      // 그냥 함수라서 undefined

console.log(new Person())  // new를 붙이면 Person은 객체를 생성하는 생성자 함수가 됨
Person {
  name: 'kim',
  first: 10,
  second: 20,
  third: 30,
  sum: [Function (anonymous)]
}
```

- 생성자를 통해 객체를 찍어내기
```js
function Person(name, first, second, third) {
    this.name=name;
    this.first=first;
    this.second=second;
    this.third=third;
    this.sum = function(){
        return this.first + this.second + this.third;
    }
}

let kim = new Person('kim', 10, 20, 30);
let lee = new Person('lee', 10, 10, 10);

console.log(kim)
kim Person {
  name: 'kim',
  first: 10,
  second: 20,
  third: 30,
  sum: [Function (anonymous)]
}

console.log(lee)
lee Person {
  name: 'lee',
  first: 10,
  second: 10,
  third: 10,
  sum: [Function (anonymous)]
}

console.log(kim.sum())    // 60
console.log(lee.sum())    // 30
```

## 전역객체
- 전역객체(Global Object) : 특수객체이며 모든 객체는 이 전역객체의 프로퍼티
- 웹에서 전역객체는 ```window```, node.js에서는 ```global``` 
```js
let o = {'func':function() {
    alert('hello?');
}}

// 아래 둘 다 동작 결과가 같음
o.func();
window.o.func();
```

## this
- this : 함수 호출 맥락(context) 의미. 상황에 따라 this가 가리키는 대상이 달라짐
- 기본 원칙 : 함수 안의 this는 그 함수가 소속된 객체를 가르킴 (메소드가 소속된 객체 가르킴)

### 함수와 this
- 함수 안에서 사용 가능하며, this는 함수 안에서 전역 객체인 window를 의미
```js
function func() {
  if(window===this) {
    console.log("window===this");
  }
}

func();  
// window === this
// undefined
```

### 메소드와 this
- 객체 소속인 메소드의 this는 그 객체를 가르킴
- 결론적으로 함수에서 this와 같은 결과 (함수 또한 전역객체 window에 소속된 메소드이기 때문)
```js
let object = {
  func : function() {
    if (object===this) {
      console.log("object === this")
    }
  }
}

object.func()
// object === this
// undefined
```

### 생성자와 this
- 함수 내의 this와 생성자 내의 this 비교

```js
let funcThis = null;

function Func() {
  funcThis = this;
}

let object1 = Func();        // object1에 함수 할당
if (funcThis === window) {
  console.log('window')
}
// window

let object2 = new Func();    // new로 인해 object2는 객체가 됨
if (funcThis === object2) {
  console.log('object2')
}
// object2
```

### 객체로서 함수
- 함수 또한 객체이다

- 함수리터럴로 함수 만들기
```js
function sum(x,y){return x+y;}
sum(1,2)   //3
```

- 객체 형태로 함수 만들기
```js
let sum2 = new Function('x', 'y', 'return x+y;');
sum(1,2)   //3
```

### 리터럴 참고
- 객체 만들기
  - 객체리터럴 : ```let object = {  }```
  - 다른 방법 : ```new Object```
- 배열 만들기
  - 배열리터럴 : ```let array = [1, 2, 3]```
  - 다른 방법 : ```new Array(1, 2, 3)```


### apply와 this
- 함수는 apply과 call이라는 메소드를 가지고 있음
- 함수 메소드은 apply와 call을 이용하면 this 값을 제어할 수 있음
- apply 메소드를 통해 함수가 소속될 객체를 지정할 수 있고 자바스크립트를 유연하게 만듬
- 객체는 주인(master)이고 메소드는 노예(slave)

```js
let object = {}
let p = {}

function func(){
  switch(this){     // switch 조건문 사용
    case object:    // this===object 일때 실행
      console.log('object');
      break;
    case p:         // this===p 일때 실행
      console.log('p');
      break;
    case window:    // this===p 일때 실행
      console.log('window')
      break;
  }
}

func();              // window (this===widow이므로 세 번째 구문이 실행됨)
func.apply(object);  // object (this===object가 됨)
func.apply(p);       // p (this===p가 됨)

```

## Prototype
- 특수한 속성

### Prototype 통한 재사용성 높이기
- prototype을 통해 특정 객체의 속성과 메소드를 정의하여 재사용성을 높일 수 있음

```js
// prototype을 통해 생성자 내의 메소드를 정의하여, 각 찍어낸 객체들의 메소드를 동시다발적으로 수정 가능

function Person(name, first, second, third) {
    this.name=name;
    this.first=first;
    this.second=second;
}

Person.prototype.sum = function(){
    return this.first + this.second;
}

let kim = new Person('kim', 10, 20)
let lee = new Person('lee', 10, 20)
console.log(kim.sum())  // 30
console.log(lee.sum())  // 30
```

- JavaScript에서 객체 안에서 특정 속성과 메소드를 찾을 경우,
  - 객체 자신이 그 속성과 메소드를 가지고 있다면, 그것을 찾아서 사용함
  - 객체 자신이 그 속성과 메소드를 가지고 있지 않다면, 원본 객체의 프로토타입에서 찾아서 사용함

```js
function Person(name, first, second, third) {
    this.name=name;
    this.first=first;
    this.second=second;
}

Person.prototype.sum = function(){                // prototype 통해 sum 메소드 정의
    return this.first + this.second;
}

let kim = new Person('kim', 10, 20)
kim.sum = function (){                            // sum 메소드를 따로 정의
    return 'this : ' + (this.first+this.second);
}

let lee = new Person('lee', 10, 20)

console.log(kim.sum())  // this : 30  → kim 객체에는 sum이란 메소드가 정의되어 있으므로 그것을 불러옴
console.log(lee.sum())  // 30         → lee 객체에는 sum이란 메소드가 없으므로 prototype에서 불러옴
```


### Prototype 통한 상속
- 상속 : 오리지널 객체가 가지고 있는 기능을 상속받는 객체가 동일하게 가질 수 있음
- 상속 받은 후 기능을 변형하여 재활용 할 때 의미가 있음
- prototype은 상속의 수단으로, prototype 안에는 객체가 있음

```js
// 생성자 대신 prototype이란 프로퍼티의 객체를 활용하여 객체의 프로퍼티 정의
function Person (name) {
  this.name = name;
}

Person.prototype.name=null
Person.prototype.introduce = function(){
  return 'My name is ' + this.name;
}

let p1 = new Person('Jacob')
p1.introduce()  // "My name is Jacob"


// prototype 통한 상속 예시
function Programmer(name){
  this.name = name;
}
Programmer.prototype = new Person();  // Person의 prototype 속성이 Programmer 객체에 반영

let p2 = new Programmer('Jiyun');
p2.introduce()   // prototype 덕분에 Programmer 생성자 안에 introduce 메소드 사용 가능해짐
```




```js
function Person(name) {
  this.name = name;
}
Person.prototype.name=null;
Person.prototype.introduce = function(){
  return 'My name is ' + this.name;
}

function Programmer(name){
  this.name = name;
}
Programmer.prototype = new Person();        // Person()의 프로퍼티를 상속받음
Programmer.prototype.coding = function(){   // 상속받은 속성 외에 coding 메소드 정의
  return "hello world";
}

function Designer(name){
  this.name = name;
}
Designer.prototype = new Person();          // Person()의 프로퍼티를 상속받음
Designer.prototype.design = function(){     // 상속받은 속성 외에 design 메소드 정의
  return "beautiful!"
}

let p1 = new Programmer('Jacob')
p1.introduce()  // "My name is Jacob"
p1.coding()     // "hello world"

let p2 = new Designer('Jiyun')
p2.introduce()  // "My name is Jiyun"
p2.design()     // "beautiful!"
```



### Prototype chain
```js
function Ultra(){}
Ultra.prototype.ultraProp = true;

function Super(){}
Super.prototype = new Ultra();

function Sub(){}
Sub.prototype = new Super();

var o = new Sub();

console.log(o.ultraProp) // true
```

## 표준 내장 객체 (Standard Bulit-in Object)
- JavaScript 내장 객체 : 사용자 정의 객체와 대비됨

### JavaScript 내장 객체 종류
- Object
- function
- Array
- String
- boolean
- Number
- Math
- Date
- RegExp

### 배열의 확장
- Array 생성자
  - 기능 : 새로운 Array객체(배열) 생성할 때 사용됨
  - 문법 : ```Array(element)```, ```new Array(element)```
```js
arr = Array(1,2,3)
arr2 = new Array(4,5,6)

arr   // [1,2,3]
arr2  // [4,5,6]
```


## Class

### 배경
- 과거 JavaScript는 Class를 지원하지 않고, Function과 Constructor로 객체를 생성해옴
- JavaScript에서 객체를 생성하기 위해 Class를 도입함
- Class는 자바, 파이썬 등에서 객체를 만들 때 사용함
- ECMA Script6 (ES6) Version부터 동작됨
- 

