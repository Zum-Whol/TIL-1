

## 오리엔테이션

- 오리엔테이션
  - 객체 : 변수와 메소드를 그루핑 한 단위
  - 연관된 것 그루핑 : 연관된 변수와 메소드는 같은 객체에 담고, 그게 아니면 다른 객체에 담기
  - 객체를 다른 곳에 사용하여 재사용성 높일 수 있음
  - 좋은 부품을 만드는 것이 목적

- 추상화 (abstract)
  - 현실은 소프트웨어보다 복잡함
  - 추상화 : 현실에서 필요한 부분만 현실에서 추출해서 단순화 시키는 것
  - 예시 : 지하철노선도는 실제 지도와는 다르게 지하철 타는데 필요한 정보만 단순화
  - 해결해야하는 문제를 소프트웨어상에서 단순화시킴

- 부품화
  - 부품화 : 로직이 재활용 가능하도록 하여 재사용성 높이는 것 
  - 부품화가 안 되어있으면 부분이 고장났을 때 전체를 교체해야 함
  - 메소드도 부품화된 특성 (중복적으로 자주 사용되는 것을 따로 정의해서 재활용성 높인 것)

- 은닉화(Information Hiding), 캡슐화(Encapsulation)
  - 내부 동작 방법을 단단한 케이스(객체) 안에 숨기고, 사용자에게는 부품의 사용방법만 노출
  - 객체를 모르고도 객체 사용할 수 있게 함

- 인터페이스
  - 장치와 장치의 연결점 접점으로 부품들 간의 약속
  - 규격화된 부품과 부품을 서로 교환할 수 있음 (본체에 어떤 모니터를 꽂아도 작동 가능)

## 생성자와 New

### 객체 생성 방법
- 자바스크립트는 프로토타입 기반 프로그램에 속함 (기존 객체 지향 패러다임과는 상이할 수 있음)
- 객체에 변수가 값으로 담겨있으면 프로퍼티(property), 함수가 값으로 담겨있으면 메소드(method)라고 함

- 아래 두 가지 방법으로 객체를 만들 수 있음. 두 번째 방법이 좀 더 직관적인 방법
```js
let person = {}
person.name = 'egoing';
person.introdue = function() {
    return `my name is `+this.name;  // this는 person 객체를 뜻함
}
```
```js
let person = {
    'name': 'egoing',
    'introduce': function() {
        return `My name is `+this.name;
    }
}
```

### 생성자(Constructor)
- 생성자 : 객체를 만드는 역할. 객체에 대한 초기화를 함
- 함수 앞에 new를 붙이면 그 함수는 객체를 만드는 생성자가 됨

```js
function Person(name) {
    this.name = name;
    this.introduce = function() {
        return 'My name is ' + this.name;
    }
}

let p1 = new Person ('Jacob');
console.log(p1) // Person {name: "Jacob", introduce: f}
p1.introduce()  // "My name is Jacob"

let p2 = new Person ('Jiyun');
console.log(p2) // Person {name: "Jiyun", introduce: f}
p1.introduce()  // 'My name is Jiyun'
```

## 전역객체
- 전역객체(Global Object) : 특수객체이며 모든 객체는 이 전역객체의 프로퍼티
- 웹에서 전역객체는 ```window```, node.js에서는 ```global``` 
```js
let o = {'func':function() {
    alert('hello?');
}}

// 아래 둘 다 동작 결과가 같음
o.func();
window.o.func();
```

## this
- this : 함수 호출 맥락(context) 의미. 상황에 따라 this가 가리키는 대상이 달라짐
- 기본 원칙 : 함수 안의 this는 그 함수가 소속된 객체를 가르킴

### 함수와 this
- 함수 안에서 사용 가능하며, this는 함수 안에서 전역 객체인 window를 의미
```js
function func() {
  if(window===this) {
    console.log("window===this");
  }
}

func();  
// window === this
// undefined
```

### 메소드와 this
- 객체 소속인 메소드의 this는 그 객체를 가르킴
- 결론적으로 함수에서 this와 같은 결과 (함수 또한 전역객체 window에 소속된 메소드이기 때문)
```js
let object = {
  func : function() {
    if (object===this) {
      console.log("object === this")
    }
  }
}

object.func()
// object === this
// undefined
```

### 생성자와 this
- 함수 내의 this와 생성자 내의 this 비교

```js
let funcThis = null;

function Func() {
  funcThis = this;
}

let object1 = Func();        // object1에 함수 할당
if (funcThis === window) {
  console.log('window')
}
// window

let object2 = new Func();    // new로 인해 object2는 객체가 됨
if (funcThis === object2) {
  console.log('object2')
}
// object2
```

### 객체로서 함수
- 함수 또한 객체이다

- 함수리터럴로 함수 만들기
```js
function sum(x,y){return x+y;}
sum(1,2)   //3
```

- 객체 형태로 함수 만들기
```js
let sum2 = new Function('x', 'y', 'return x+y;');
sum(1,2)   //3
```

### 리터럴 참고
- 객체 만들기
  - 객체리터럴 : ```let object = {  }```
  - 다른 방법 : ```new Object```
- 배열 만들기
  - 배열리터럴 : ```let array = [1, 2, 3]```
  - 다른 방법 : ```new Array(1, 2, 3)```


### apply와 this
- 함수는 apply과 call이라는 메소드를 가지고 있음
- 함수 메소드은 apply와 call을 이용하면 this 값을 제어할 수 있음
- apply 메소드를 통해 함수가 소속될 객체를 지정할 수 있고 자바스크립트를 유연하게 만듬
- 객체는 주인(master)이고 메소드는 노예(slave)

```js
let object = {}
let p = {}

function func(){
  switch(this){     // switch 조건문 사용
    case object:    // this===object 일때 실행
      console.log('object');
      break;
    case p:         // this===p 일때 실행
      console.log('p');
      break;
    case window:    // this===p 일때 실행
      console.log('window')
      break;
  }
}

func();              // window (this===widow이므로 세 번째 구문이 실행됨)
func.apply(object);  // object (this===object가 됨)
func.apply(p);       // p (this===p가 됨)

```

## 상속
- 상속 : 오리지널 객체가 가지고 있는 기능을 상속받는 객체가 동일하게 가질 수 있음
- 상속 받은 후 기능을 변형하여 재활용 할 때 의미가 있음
- prototype이라는 특수한 속성 활용하기. prototype 안에는 객체가 있음

```js
// 생성자 대신 prototype이란 프로퍼티의 객체를 활용하여 객체의 프로퍼티 정의
function Person (name) {
  this.name = name;
}

Person.prototype.name=null
Person.prototype.introduce = function(){
  return 'My name is ' + this.name;
}

let p1 = new Person('Jacob')
p1.introduce()  // "My name is Jacob"


// prototype 통한 상속 예시
function Programmer(name){
  this.name = name;
}
Programmer.prototype = new Person();  // Person의 prototype 속성이 Programmer 객체에 반영

let p2 = new Programmer('Jiyun');
p2.introduce()   // prototype 덕분에 Programmer 생성자 안에 introduce 메소드 사용 가능해짐
```

```js
function Person(name) {
  this.name = name;
}
Person.prototype.name=null;
Person.prototype.introduce = function(){
  return 'My name is ' + this.name;
}

function Programmer(name){
  this.name = name;
}
Programmer.prototype = new Person();        // Person()의 프로퍼티를 상속받음
Programmer.prototype.coding = function(){   // 상속받은 속성 외에 coding 메소드 정의
  return "hello world";
}

function Designer(name){
  this.name = name;
}
Designer.prototype = new Person();          // Person()의 프로퍼티를 상속받음
Designer.prototype.design = function(){     // 상속받은 속성 외에 design 메소드 정의
  return "beautiful!"
}

let p1 = new Programmer('Jacob')
p1.introduce()  // "My name is Jacob"
p1.coding()     // "hello world"

let p2 = new Designer('Jiyun')
p2.introduce()  // "My name is Jiyun"
p2.design()     // "beautiful!"
```

## 프로토타입
- Prototype(원형) : 상속의 수단

- Prototype chain
```js
function Ultra(){}
Ultra.prototype.ultraProp = true;

function Super(){}
Super.prototype = new Ultra();

function Sub(){}
Sub.prototype = new Super();

var o = new Sub();

console.log(o.ultraProp) // true
```

## 표준 내장 객체 (Standard Bulit-in Object)
- JavaScript 내장 객체 : 사용자 정의 객체와 대비됨

### JavaScript 내장 객체 종류
- Object
- function
- Array
- String
- boolean
- Number
- Math
- Date
- RegExp

### 배열의 확장
