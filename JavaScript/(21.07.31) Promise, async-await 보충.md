# Promise, async-await 보충
- 드림코딩 엘리 영상 요약

***

## 콜백함수와 비동기

### 1. 콜백 함수

- 동기적 콜백 함수
```js
function printImmediately(print) {
  print();
}
printImmediately(() => console.log('hello'));
```

- 비동기적 콜백 함수
```js
// setTimeout으로 시간 설정

function printWithDelay(print, timeout) {
  setTimeout(print, timeout);
}
printWithDelay(() => console.log('async callback'), 2000);
```

- 콜백 지옥 예시
```js
class UserStorage {
  loginUser(id, password, onSuccess, onError) {
      setTimeout(()=> {
        if(
          (id === 'jacob' && password === '1234') ||
          (id === 'jiyun' && password === '12345')
        ) {
          onSuccess(id);
        } else {
          onError(new Error('not found'))
        }

      }, 2000);
  }

  getRoles(user, onSuccess, onError) {
    setTimeout(()=> {
      if (user === 'jacob') {
        onSuccess({ name:'jacob', role:'leader'});
      } else {
        onError(new Error('not found'))
      }
    }, 1000);

  }
}
```

***

## Promise

### 1. Promise란?
- Promise : 자바스크립트에서 제공하는 비동기 간편하게 처리할 수 있는 object
- 용도 : 콜백함수 대신 유용하게 사용

### 2. Promise의 상태와 결과
- 상태(State) : 프로세스가 수행중인지 완료되었는지 보여줌
  - Pending : 프로세스가 수행중인 상태

- 결과 : 프로세스가 완료된 상태
  - fulfilled : 프로세스가 완료되어 성공한 상태
  - rejected : 프로세스가 완료되었지만 실패한 상태

### 3. Promise의 특징
- Promise 안에는 heavy한 작업이 들어가는데, 시간이 걸리는 이 작업을 비동기적으로 실행하여 그 동안 다른 작업도 가능하게 하기 위함
- Promise 객체를 만들자마자 콜백함수가 바로 실행되기 때문에 클라이언트가 요청했을 때만 실행될 수 있도록 통제가 필요한 경우가 있음
- Promise의 생성자를 보면 Promise 안에 2개의 콜백함수를 받게 되어 있음 (성공시 전달할 resolve, 실패시 전달할 reject)

### 3. Promise 사용법
- Producer를 통한 Promise 생성 : new 키워드와 Promise 생성자 사용
  - 콜백함수 resolve() : 성공 시 전달할 값을 괄호 안에 입력
  - 콜백함수 reject() : 실패 시 전달할 값을 괄호 안에 입력

```js
const promise = new Promise((resolve, reject) => {   // promise 는 클래스이기 때문에 new 키워드로 객체 생성 가능
    console.log('doing something...');
    setTimeout(() => {
      resolve('jacob');                       // resolve 괄호 안에있는 값이 전달됨
      /* reject(new Error('no network')); */  // Error 클래스는 자바스크립트에서 제공하는 클래스이며 에러가 발생하는 걸 나타내는 객체
    }, 2000);
  });
```

- Consumer를 통한 Promise 사용 : Consumer문 안에 콜백함수를 넣어서 값을 받아오기 
  - then : Promise가 정상적으로 수행될 때, resolve() 괄호 안의 값을 받을 때 사용

  - catch : promise 수행이 실패할 경우, reject() 괄호 안의 값을 받을 때 사용

  - finally : 성공/실패와 상관없이 마지막에 기능을 수행

  - Consumer문에서 return을 하면 다음 consumer 문은 이 return 값을 받음

```js
promise.then(value => {   // value는 resolve 콜백 함수 안에 들어있는 'jacob' 이 됨
      console.log(value);
  })                     // 위의 then은 결국 똑같은 promise를 리턴하기 때문에 바로 catch 사용 가능 - 이것이 promise chaining
  .catch(error=> {       // catch문은 promise 수행이 실패할 경우 reject값을 받을 때 사용
      console.log(error)
  })
  .finally(()=> {            // finally는 최근데 등장한 것으로 성공/실패와 상관없이 기능을 마지막에 수행
      console.log('finally');
  });
  
```

- Promise Chaining
```js
  const fetchNumber = new Promise((resolve, reject) => {
      setTimeout(() => resolve(1), 1000);
  });
  
  fetchNumber
  .then(num => num * 2)   // num은 2가 됨  // return을 해주면 그 값을 다음 .then에서 받음
  .then(num => num*3)     // num은 6이 됨
  .then(num=> {  // then은 또 다른 promise를 리턴할 수 있음
      return new Promise((resolve, reject) => {
          setTimeout(() => resolve(num - 1),1000);  // num은 5가 됨
      });
  })
  .then (num => console.log(num));
```

- Error Handling
```js
const getHen = () =>
  new Promise((resolve, reject) => {
      setTimeout(() => resolve('🐔'),1000);
  });
const getEgg = hen =>
  new Promise((resolve, reject) => {
      setTimeout(() => resolve(`${hen} => 🥚`), 1000);
  });
const cook = egg =>
  new Promise((resolve, reject) => {
      setTimeout(() => resolve(`${egg} => 🍳`), 1000);
  });

getHen()
.then(hen => getEgg(hen))         // .then(getEgg)로 표기 가능 : 받아오는 값을 콜백함수에서 바로 호출하는 경우
.catch(error => {                 // 에러핸들링 : 중단에 달걀을 받을 수 없으면 빵으로 대체
    return '🥖';
})
.then(egg => cook(egg))           // .then(cook)
.then(meal => console.log(meal)) // .then(console.log)
.catch(console.log);
```

***

## async - await
