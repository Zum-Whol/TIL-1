# JavaScript 클로저(Closure)
코드스테이츠 (2021.05.28)

***

## 클로저(Closure)
- 클로저 : 함수와 함수가 선언된 어휘적(lexical) 환경의 조합
- 어휘적 환경 : 변수 및 함수 선언의 형태

## 클로저 함수
- 클로저 함수 : 외부함수의 컨텍스트에 접근할 수 있는 내부함수
- 리턴하는 함수에 의해 스코프(변수 접근 범위)가 결정됨
  - 클로저의 핵심은 스코프를 이용해서 변수의 접근 범위를 닫는데 있음
  - 따라서 함수를 리턴하는 것만큼 변수가 선언된 곳이 중요

- 클로저 함수의 기본 형태
  ```js
  let adder = function (x) {  // 외부 함수이며 x는 외부 함수의 변수
      return function (y) {   // 리턴 값이 함수 형태인 내부 함수
          return x + y;       // y는 내부 함수 변수
      }
  }

  add(5)(7)                   // 12 (클로저 함수는 호출이 2번 발생함)
  ```
  - 이 클로저 함수는 스코프가 분리됨
  - 내부 함수는 외부 함수 변수인 x에 접근이 가능하지만, 외부 함수는 y에 접근 불가능

## 클로저의 활용

### 1. 데이터를 보존하는 함수
- 일반적인 함수는 함수 실행이 끝나면 내부 변수 사용할 수 없음
- 반면 클로저는 외부 함수의 실행이 끝나더라도, 외부 함수 내 변수가 메모리에 저장됨 (어휘적 환경을 메모리에 저장)
    ```js
  let adder = function (x) { 
      return function (y) {  
          return x + y;       
      }
  }

  const add5 = adder(5);  
  // 외부함수의 실행이 끝나더라도 외부 함수 내 변수(x) 사용 가능
  ```
- HTML 문자열 생성기 예시
   ```js
   const tagMaker = tag => content => `<${tag}>${content}</${tag}>`

   const divMaker = tagMaker('div')  // 외부 함수의 변수를 'div'로 저장
   divMaker('hello')                 // '<div>hello</div>'
   divMaker('codestates')            // '<div>codestates</div>'
   ```
   - 이처럼 클로저는 특정 데이터를 스코프 안에 가두어 둔 채로 계속 사용하게 해줌

### 2. 클로저 모듈 패턴
- 모듈화 : 함수 재사용성을 극대화하여 함수 하나를 완전히 독립적인 형태로 분리하는 것
- 캡슐화 : 스코프 규칙으로 정보의 접근 제한
```js
const makeCounter = () => {
    let value = 0;

    return {                    // 객체를 담아 내부 함수 여러개 리턴
        increase: () => {
            value = value + 1
        },
        decrease: () => {
            value = value - 1
        },
        getValue: () => value
    }
}

const counter1 = makeCounter();
counter1                          // { increase: f, decrease: f, getValue: f }
counter1.increase();
counter1.increase();
counter1.decrease();
counter1.getValue();              // 1

const counter2 = makeCounter();
counter2.decrease();
counter2.decrease();
counter2.decrease();
counter2.getValue();              //-3
```
  - makeCounter 함수를 바꾸지 않고 value 라는 변수에 값을 새롭게 할당할 수 없음
  - makeCounter에 의해 리턴된 객체는 value 값을 각자 독립적으로 가짐
  - counter1에서 value와 counter2에서 value는 서로 영향을 주지 않고 각각 독립된 값 보존
