# 비동기

***

## 콜백함수 리뷰

- 종류 : 반복 실행하는 함수 (iterator) & 이벤트에 따른 함수 (event handler)
- 주의사항 : 콜백은 함수 자체를 연결하는 것이지, 함수를 실행시키는 것이 아님
- 함수 뒤에 괄호()가 있으면 함수를 실행시키는 것이며, 괄호가 없으면 함수 자체를 뜻함
  ```js
  function functionParameter(func, num) {  // 함수 자체를 인자로 전달하기
  return func(num)                         // return문에서 함수를 실행함
  }
  ```
  ```js
  function handleClick() {
    console.log('button clicked');

  document.querySelector('#btn').onclick = handleClick;    // 함수 자체를 연결함 (정답)
  document.querySelector('#btn').onclick = handleClick();  // 함수를 실행을 연결함 (오답)
  }
  ```

***

## 비동기 개념

### 1. 동기와 비동기
- 블로킹(Blocking) : 하나의 작업이 끝날 때까지 이어지는 작업을 막는 것
- 동기(Synchronous) : blocking을 통해 하나의 작업이 끝나기 전까지는 이어지는 작업을 처리할 수 없는 방식이며, 요청에 대한 결과가 동시에 일어남
- 비동기(Asynchonous execution) : non-blocking하여 순서와 상관없이 작업할 수 있는 방식이며, 요청에 대한 결과가 동시에 일어나지 않음

### 2. 비동기의 주요 사례
- DOM Element의 이벤트 핸들러
  - 마우스, 키보드 입력 (click, keydown 등)
  - 페이지 로딩 (DOMContentLoaded 등)
- 타이머
  - 타이머 API (setTimeout 등)
  - 애니메이션 API (requestAnimationFrame)
- 서버에 자원 요청 및 응답
  - fetch API
  - AJAX (XHR)

### 3. 비동기 작동 원리 참고
- Event Loop : http://developer.mozila.org/ko/docs/Web/javaScript/EventLoop

- Philip Roberts : Help, I'm stuck in an event-loop https://vimeo.com/96425312

### 4. 비동기 호출
- 비동기 함수 전달 패턴1 : callback 패턴
  ```js
  let request = 'caffelatte'
  orderCoffeeAsync(request, function(response) { 
    drink (response);                             // response는 주문한 커피 결과
  });
  ```

- 비동기 함수 전달 패턴2 : 이벤트 등록 패턴
  ```js
  let request = 'caffelatte'
  orderCoffeeAsync(request).onready = function(response) { 
    drink (response);                                      // response는 주문한 커피 결과
  });
  ```

***

## 비동기 제어 방법

### 1. 콜백
- 순서가 제어 안 된 비동기(Async) 예시
```js
const printString = (string) => {
  setTimeout(
    () => {
      console.log(string)
    },
    Math.floor(Math.random() * 100) + 1
  )
}

const printAll = () => {
  printString("A")
  printString("B")
  printString("C")
}
printAll() // A B C 의 순서가 랜덤으로 반환
```

- 콜백함수로 순서 제어
```js
const printString = (string, callback) => {
  setTimeout(
    () => {
      console.log(string)
      callback()
    },
    Math.floor(Math.random() * 100) + 1
  )
}

const printAll = () => {
  printString("A", () => {
    printString("B", () => {
      printString("C", () => {})
    })
  })
}
printAll() // A B C 순서대로 리턴
```

- Error 핸들링 디자인
```js
const somethingGonnaHappen = callback => {
  waitingUntilSomethingHappens()

  if (isSomethingGood) {
    callback (null, something)
  }
  if (isSomethingBad) {
    callback (errorSomething, null)
  }
}
```
  - Usage
  ```js
  somethingGonnaHappen((err, data) => {  // 보통 앞에 에러값, 뒤에 원하는 결과값
    if (err) {
      console.log('ERR!!');
      return;
    }
    return data;
  })
  ```

### 2. Promise

- Promise 사용 이유
  - 콜백 함수가 계속 이어지면 콜백 헬에 빠짐
  - 콜백 핸들링하기 위해 Promise 필요

- Promise 사용 방법
  - Promise도 하나의 클래스
  - new Promise()를 통해 instance를 만들고 resolve()와 reject() 명령어로 핸들링 (resolve와 reject도 함수)
  - data는 ```.then```으로, error는 ```.catch```로 연결

<img width="400" alt="스크린샷 2021-06-23 오전 11 32 34" src="https://user-images.githubusercontent.com/80403988/123039923-dd848b00-d42d-11eb-934b-1a241d1d5668.png">

```js
const printString = (string) => {
  return new Promise((resolve, reject) => {    // new Promise를 리턴 해줌
      setTimeout(
        () => {
          console.log(string)
          resolve()
        },
        Math.floor(Math.random() * 100) + 1
      )
  })
}

const printAll = () => {
  printString("A")
  .then(() => {                    // then으로 연결해줌
    return printString("B")
  })
  .then(() => {
    return printString("C")
  })                               // 에러 핸들링은 then이 아닌 catch로 가능
}
printAll()
```

- Promise Chaning
  - 사용 이유 : 함수가 여러개일 때 promise hell에 빠질 수 있음
  - 방법 : 함수 내 다른 함수를 리턴해준 뒤, ```.then```으로 연결

```js
function gotoCodestates() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {resolve('1. go to codestates'),100})
  })
}

function sitAndCode() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {resolve('2. sit and code'),100})
  })
}

function eatLunch() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {resolve('3. eat lunch'),100})
  })
}

function gotoBed() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {resolve('4. go to bed'),100})
  })
}
```
```js
//promise hell
gotoCodestates()
.then(data => {
  console.log(data)

  sitAndCode()
  .then(data => {
    console.log(data)

    eatLunch()
    .then(data=> {
      console.log(data)

      goToBed()
      .then(data => {
        console.log(data)
      })
    })
  })
})
```
```js
//Promise Chaning 적용
gotoCodestates()
.then(data => {
  cosole.log(data)
  return sitAndCode()
})
.then(data => {
  console.log(data)
  return eatLunch()
})
.then(data => {
  console.log(data)
  return goTobed()
})
.then(data => {
  console.log(data)
})
```

### 3. async await
- Promise의 업그레이드 버전
```js
const result = async () => {
  const one = await gotoCodestates();
  console.log(one)

  const one = await sitAndCode();
  console.log(two)
  
  const one = await eatLunch();
  console.log(three)

  const one = await goToBed();
  console.log(four)
}
```
***

## 타이머 API

- setTimeout
  - 기능 : 일정 시간 후에 함수를 실행
  - 문법 : ```setTimeout (callback, millisecond)```
  - arguments : 실행할 callback 함수, callback 함수 실행 전 기다려야 할 시간 (밀리초)
  - return value : 임의이 타이머 ID
  ```js
  setTimeout(function () {
  console.log('1초 후 실행');
  }, 1000);
  // 123
  ```

- setInterval
  - 기능 : 일정 시간의 간격을 가지고 함수를 반복적으로 실행
  - 문법 : ```setInterval (callback, millisecond)```
  - arguments : 실행할 callback 함수, 반복적으로 함수를 실행시키기 위한 시간 간격 (밀리초)
  - return value : 임의의 타이머 ID
  ```js
  setInterval(function () {
  console.log('1초마다 실행');
  }, 1000);
  // 345
  ```

- clearInterval
  - 기능 : 반복 실행중인 타이머를 종료
  - 문법 : ```clearInterval (timerId)```
  - arguments : 타이머 ID
  - return value : 없음
  ```js
  const timer = setInterval(function () {
  console.log('1초마다 실행');
  }, 1000);
  clearInterval(timer);
  // 더 이상 반복 실행되지 않음
  ```
***

## Sprint 과제 

### Part2 - fs 모듈

- callback 함수를 구현하고 테스트를 통과하세요
```js
const getDataFromFile = function (filePath, callback) {
  fs.readFile(filePath, "utf8", (err,data) => {        //"utf8"을 입력해야 영어 외 모든 언어 사용 가능하며 그렇지 않으면 특수문자 나옴
  if(err) {
    callback (err, null);
  } else{
  callback (null, data)
  }
});
}
```
```js
const getDataFromFile = function (filePath, callback) {
  fs.readFile(filePath, function (err,data) {      
  if(err) {
    callback (err, null);
  } else{
  callback (null, data.toString())                   // "utf8" 생략한 대신 data에 toString() 메소드 사용
  }
});
}
```

- callback이라는 인자 대신, Promise의 reject, resolve 함수를 이용하세요.
```js
const getDataFromFilePromise = filePath => {
  return new Promise((resolve,reject)=>{
    fs.readFile(filePath, "utf8", (err,data) =>{
      if(err) {
      reject(err)
      } else {
      resolve(data)
      }
    })
  })
};
```

- Promise Chaning을 사용해야 하며 getDataFromFilePromise를 이용하세요.
  - ```files/user1.json```파일과 ```files/user2.json```을 불러오고, 두 파일을 합쳐서 최종적으로 두 객체가 담긴 배열 만들기
  - then이 어떤 parameter를 전달받는지 이해하기 : 상위 함수의 리턴값
  - then의 return이 무엇을 의미하는지 이해하기 : 함수의 리턴
  - 파일 읽기의 결과가 문자열이므로, JSON.parse를 사용해야 함
```js
const user1Path = path.join(__dirname, 'files/user1.json');
const user2Path = path.join(__dirname, 'files/user2.json');

const readAllUsersChaining = () => {
  // TODO: 여러개의 Promise를 then으로 연결하여 작성합니다
return getDataFromFilePromise(user1Path)
.then(function(user1){
  return getDataFromFilePromise(user2Path)
  .then(function(user2){
    return `[${user1}, ${user2}]`
  })
}).then(function(text){
  return JSON.parse(text);
})
}
```

```js
// 페어와 만든 코드
return new Promise ((resolve, reject) => {
  let result = [];
  getDataFromFilePromise(user1Path)
  .then((data) => {
    result.push(JSON.parse(data));
    return getDataFromFilePromise(user2Path)
  })
  .then((data) => {
    result.push(JSON.parse(data));
    resolve(result);
  });
});
};
```