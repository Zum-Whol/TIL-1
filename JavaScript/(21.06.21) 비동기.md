# 비동기
(2021.06.21)

## 콜백함수 리뷰

- 종류 : 반복 실행하는 함수 (iterator) & 이벤트에 따른 함수 (event handler)
- 주의사항 : 콜백은 함수 자체를 연결하는 것이지, 함수를 실행시키는 것이 아님
- 함수 뒤에 괄호()가 있으면 함수를 실행시키는 것이며, 괄호가 없으면 함수 자체를 뜻함
  ```js
  function functionParameter(func, num) {  // 함수 자체를 인자로 전달하기
  return func(num)                         // return문에서 함수를 실행함
  }
  ```
  ```js
  function handleClick() {
    console.log('button clicked');

  document.querySelector('#btn').onclick = handleClick;    // 함수 자체를 연결함 (정답)
  document.querySelector('#btn').onclick = handleClick();  // 함수를 실행을 연결함 (오답)
  }
  ```

## 비동기 개념

### 1. 동기와 비동기
- 블로킹(Blocking) : 하나의 작업이 끝날 때까지 이어지는 작업을 막는 것
- 동기(Synchronous) : blocking을 통해 하나의 작업이 끝나기 전까지는 이어지는 작업을 처리할 수 없는 방식이며, 요청에 대한 결과가 동시에 일어남
- 비동기(Asynchonous execution) : non-blocking하여 순서와 상관없이 작업할 수 있는 방식이며, 요청에 대한 결과가 동시에 일어나지 않음

### 2. 비동기의 주요 사례
- DOM Element의 이벤트 핸들러
  - 마우스, 키보드 입력 (click, keydown 등)
  - 페이지 로딩 (DOMContentLoaded 등)
- 타이머
  - 타이머 API (setTimeout 등)
  - 애니메이션 API (requestAnimationFrame)
- 서버에 자원 요청 및 응답
  - fetch API
  - AJAX (XHR)

### 3. 비동기 작동 원리 참고
- Event Loop : http://developer.mozila.org/ko/docs/Web/javaScript/EventLoop

- Philip Roberts : Help, I'm stuck in an event-loop https://vimeo.com/96425312

### 4. 비동기 호출
- 비동기 함수 전달 패턴1 : callback 패턴
  ```js
  let request = 'caffelatte'
  orderCoffeeAsync(request, function(response) { 
    drink (response);                             // response는 주문한 커피 결과
  });
  ```

- 비동기 함수 전달 패턴2 : 이벤트 등록 패턴
  ```js
  let request = 'caffelatte'
  orderCoffeeAsync(request).onready = function(response) { 
    drink (response);                                      // response는 주문한 커피 결과
  });
  ```

## 비동기 제어 방법

### 1. 콜백
- 순서가 제어 안 된 비동기(Async) 예시
```js
const printString = (string) => {
  setTimeout(
    () => {
      console.log(string)
    },
    Math.floor(Math.random() * 100) + 1
  )
}

const printAll = () => {
  printString("A")
  printString("B")
  printString("C")
}
printAll() // A B C 의 순서가 랜덤으로 반환
```

- 콜백함수로 순서 제어
```js
const printString = (string, callback) => {
  setTimeout(
    () => {
      console.log(string)
      callback()
    },
    Math.floor(Math.random() * 100) + 1
  )
}

const printAll = () => {
  printString("A", () => {
    printString("B", () => {
      printString("C", () => {})
    })
  })
}
printAll() // A B C 순서대로 리턴
```

- Error 핸들링 디자인
```js
const somethingGonnaHappen = callback => {
  waitingUntilSomethingHappens()

  if (isSomethingGood) {
    callback (null, something)
  }
  if (isSomethingBad) {
    callback (errorSomething, null)
  }
}
```
  - Usage
  ```js
  somethingGonnaHappen((err, data) => {  // 보통 앞에 에러값, 뒤에 원하는 결과값
    if (err) {
      console.log('ERR!!');
      return;
    }
    return data;
  })
  ```

### 2. Promise

- Promise 사용 이유
  - 콜백 함수가 계속 이어지면 콜백 헬에 빠짐
  - 콜백 핸들링하기 위해 프로미스 필요

- Promise 사용 방법
  - Promise도 하나의 클래스
  - new Promise()를 통해 instance를 만들고 resolve()와 reject() 명령어로 핸들링 (resolve와 reject도 함수)
  - data는 ```.then```으로, error는 ```.catch```로 연결

<img width="300" alt="스크린샷 2021-06-23 오전 11 32 34" src="https://user-images.githubusercontent.com/80403988/123039923-dd848b00-d42d-11eb-934b-1a241d1d5668.png">

```js
const printString = (string) => {
  return new Promise((resolve, reject) => {    // new Promise를 리턴 해줌
      setTimeout(
        () => {
          console.log(string)
          resolve()
        },
        Math.floor(Math.random() * 100) + 1
      )
  })
}

const printAll = () => {
  printString("A")
  .then(() => {                    // then으로 연결해줌
    return printString("B")
  })
  .then(() => {
    return printString("C")
  })                               // 에러 핸들링은 then이 아닌 catch로 가능
}
printAll()
```

- Promise Chaning
  - 사용 이유 : 함수가 여러개일 때 promise hell에 빠질 수 있음
  - 방법 : 함수 내 다른 함수를 리턴해준 뒤, ```.then```으로 연결

```js
function gotoCodestates() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {resolve('1. go to codestates'),100})
  })
}

function sitAndCode() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {resolve('2. sit and code'),100})
  })
}

function eatLunch() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {resolve('3. eat lunch'),100})
  })
}

function gotoBed() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {resolve('4. go to bed'),100})
  })
}
```
```js
//promise hell
gotoCodestates()
.then(data => {
  console.log(data)

  sitAndCode()
  .then(data => {
    console.log(data)

    eatLunch()
    .then(data=> {
      console.log(data)

      goToBed()
      .then(data => {
        console.log(data)
      })
    })
  })
})
```
```js
//Promise Chaning 적용
gotoCodestates()
.then(data => {
  cosole.log(data)
  return sitAndCode()
})
.then(data => {
  console.log(data)
  return eatLunch()
})
.then(data => {
  console.log(data)
  return goTobed()
})
.then(data => {
  console.log(data)
})
```

### 3. async await
- Promise의 업그레이드 버전
```js
const result = async () => {
  const one = await gotoCodestates();
  console.log(one)

  const one = await sitAndCode();
  console.log(two)
  
  const one = await eatLunch();
  console.log(three)

  const one = await goToBed();
  console.log(four)
}
```
