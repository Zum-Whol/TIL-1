# 문자열과 그래픽

***

## 문자열
- 1byte = 8bits
- 과거에는 알파벳 하나가 1byte
- UTF-8은 ASCII 코드의 경우 1 byte, 크게 영어 외 글자는 2byte, 3byte, 보조 글자(이모지 등)는 4byte를 차지
- UTF-8에서는 한글은 3 바이트, UTF-16에서는 2 바이트를 차지
- 변환 사이트 : https://dencode.com/

### 1. 유니코드(Unidocde)
- 유니코드 : 유니코드 협회(Unicode Consortium)가 제정하는 전 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 산업 표준
- 이 표준에는 ISO 10646 문자 집합, 문자 인코딩, 문자 정보 데이터베이스, 문자를 다루기 위한 알고리즘 등을 포함
- 유니코드의 목적 : 현존하는 문자 인코딩 방법을 모두 유니코드로 교체
- 인코딩 : 어떤 문자나 기호를 컴퓨터가 이용할 수 있는 신호로 만드는 것으로 인코딩과 디코딩의 기준은 문자열 세트 또는 문자셋(charset)이라고 부름

### 2. ASCII 문자
- 영문 알파벳을 사용하는 대표적인 문자 인코딩
- 7 비트로 모든 영어 알파벳을 표현 : 52개의 영문 알파벳 대소문자, 10개의 숫자, 32개의 특수 문자, 그리고 하나의 공백 문자를 포함
- 유니코드는 ASCII를 확장한 형태입

## UTF-8
- UTF-8 : Universal Coded Character Set + Transformation Format – 8-bit
- UTF-8은 유니코드 한 문자를 나타내기 위해 1 byte 에서 4 bytes의 가변 길이를 인코딩함
- UTF-8은 UTF-16에 비해 바이트 순서를 따지지 않고, 바이트 순서가 정해져 있으며 고정됨
- 네트워크를 통해 전송되는 텍스트는 주로 UTF-8로 인코딩 (더 작은 크기 문자열 표현 가능하기 때문)

```js
//'코'라는 문자를 UTF-8로 표현

let encoder = new TextEncoder(); // 기본 인코딩은 'utf-8'
encoder.encode('코') // Uint8Array(3) [236, 189, 148]

(236).toString(2) // "11101100"
(189).toString(2) // "10111101"
(148).toString(2) // "10010100"
```

### 3. UTF-16
- UTF-8 : Universal Coded Character Set + Transformation Format – 16-bit
- UTF-8과 UTF-16은 인코딩 방식의 차이를 의미하며 UTF-16은 유니코드 코드 대부분을 16 bits로 표현
- UTF-8에서는 한글은 3 바이트, UTF-16에서는 2 바이트를 차지
- UFT-16은 이진법으로 표현된 문자를 16 bits(2 bytes)로 그대로 사용

```
/* 문자열 '코'를 여러 유형으로 표현하기 */

이진법(binary number) : 1100-1111-0101-0100
UTF-8 : 11101100 10111101 10010100 (3 bytes = 8bits x 3)
UTF-16 : 1100-1111-0101-0100
```

## 그래픽
- 비트맵(래스터)과 벡터 이미지의 차이점
- Raster(PNG) vs Vector(SVG)

<img width="1000" alt="스크린샷 2021-08-05 오전 11 18 37" src="https://user-images.githubusercontent.com/80403988/128280603-c012275e-4404-4a12-ab0b-fdfe64730d90.png">

***

## 운영체제 개요
- 컴퓨터 시스템의 요소 4가지 : 하드웨어(CPU, 메모리, 입출력장치 등), 운영체제, 어플리케이션 프로그램, 유저
- 운영체제 : 하드웨어와 어플리케이션 프로그램에 일을 시키는 주체
- 공부 링크 : https://codex.cs.yale.edu/avi/os-book/OS10/index.html
- 한글 링크 : https://parksb.github.io/article/5.html

<img width="550" alt="스크린샷 2021-08-05 오후 12 01 48" src="https://user-images.githubusercontent.com/80403988/128284601-32f7ff5c-02fe-453e-917e-8e23cc31dbe8.png">

### 1. 시스템 자원 관리
- 운영체제는 시스템에게 자원 할당자(Resource allocator) 역할
- 컴퓨터 시스템은 CPU 시간, 메모리 공간, 파일 저장소 공간, 입출력 장치 등 다양한 문제를 해결해야 하며 운영체제는 이러한 컴퓨터 자원들을 관리하는 제어 프로그램

- 하드웨어
  - CPU : 하드웨어 구성 및 프로세스 관리

  - 메모리 관리 (RAM)

  - I/O(입출력) 관리 (디스크, 네트워크 등)

### 2. 응용 프로그램 관리
- 응용 프로그램 : 컴퓨터를 이용해 다양한 작업을 하는 것이 목적이며 컴퓨터에게 일을 시킴
- 운영체제는 응용 프로그램이 실행되고, 시스템 자원을 사용할 수 있도록 권한과 사용자 관리 (보안과 관련)
- 권한을 부여받고 난 후에는, 운영체제가 제공하는 기능을 이용할 수 있음
- 시스템 콜(System call) : 응용 프로그램이 시스템 자원을 사용할 수 있도록, 운영체제 차원에서 다양한 함수(API)를 제공하는 것

***

## 프로세스, 스레드, 멀티 스레드

### 1. 프로세스(Process)
- 프로세스 : 운영체제에서는 실행 중인 하나의 애플리케이션
- 사용자가 애플리케이션을 실행하면, 운영체제로부터 실행에 필요한 메모리를 할당 받아 애플리케이션의 코드를 실행
- 다중 프로세스 : Chrome 브라우저를 두 개 실행하면, 두 개의 프로세스가 생성되 (하나의 애플리케이션은 여러 프로세스 만들기도 함)

### 2. 스레드(Thread)
- 스레드 : 한 가지 작업을 실행하기 위해 순차적으로 실행한 코드
- 하나의 스레드는 코드가 실행되는 하나의 흐름
- 한 프로세스 내에 스레드가 두 개라면 코드가 실행되는 흐름이 두 개 생긴다는 의미

### 3. 스레드의 특징
- 프로세스 내에서 실행되는 흐름의 단위
- 각 스레드마다 call stack이 존재(call stack: 실행중인 서브루틴을 저장하는 자료 구조)
- 스레드는 다른 스레드와 독립적으로 동작

### 4. 멀티 스레드(Multi-Thread)
- 멀티 태스킹 : 두 가지 이상의 작업을 동시에 처리하는 것을 의미
- 멀티 프로세스 : 애플리케이션 단위의 멀티 태스킹
- 멀티 스레드 : 애플리케이션 내부에서의 멀티 태스킹
- 덕분에 멀티 태스킹은 꼭 멀티 프로세스를 의미하는 것이 아니며, 하나의 프로세스에도 멀티 스레드를 통해 멀티 태스킹 가능

<img width="600" alt="스크린샷 2021-08-05 오후 1 53 11" src="https://user-images.githubusercontent.com/80403988/128293037-9abd8941-507f-467b-8fbc-61ae584a49ec.png">

### 5. 멀티 스레딩의 장단
- 프로세스를 이용하여 동시에 처리하던 일을 스레드로 구현할 경우, 메모리 공간과 시스템 자원의 소모가 줄어듬
- 스레드 간의 통신이 필요한 경우 별도의 자원을 이용하는 것이 아니라, 전역 변수의 공간 또는 동적으로 할당된 공간인 Heap 영역 이용
- 프로세스 간 통신 방법(IPC)에 비해 스레드 간의 통신 방법이 훨씬 간단
- 시스템의 처리량(Throughput)이 향상되고 자원 소모가 줄어들어 자연스럽게 프로그램의 응답 시간이 단축
- 장점 덕분에 여러 프로세스로 할 수 있는 작업을 하나의 프로세스에서 스레드로 나눠 수행

<img width="450" alt="스크린샷 2021-08-05 오후 1 54 35" src="https://user-images.githubusercontent.com/80403988/128293044-2c6660d0-0728-447d-a10f-62f860e7db2c.png">

### 6. 멀티 스레딩의 문제점
- 멀티 프로세스 기반으로 프로그래밍할 때에는 프로세스 간 공유하는 자원이 없음
- 동일한 자원에 동시에 접근하는 일이 없었지만, 멀티 스레딩을 기반으로 프로그래밍할 때에는 공유하는 자원에 대하여 고민이 필요
- 서로 다른 스레드가 같은 데이터에 접근하고, 힙 영역을 공유하기 때문에 서로 다른 스레드가 서로 사용중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정하는 일이 발생할 수 있음
- 멀티스레딩 환경에서는 동기화 작업이 필요한데, 동기화를 통해 작업 처리 순서를 제어하고 공유 자원에 대한 접근을 제어
- 데드락(Deadlock, 교착 상태), 뮤텍스(Mutex), 세마포어(Semaphore)

### 7. 동시성과 병렬성
- 동시에 돌릴 수 있는 스레드 수는 컴퓨터에 있는 코어 갯수로 제한
- 시분할 : 운영체제(또는 가상 머신)는 각 스레드를 시간에 따라 분할하여, 여러 스레드가 일정 시간마다 돌아가면서 실행되도록 함
- Concurrency(동시성, 병행성): 여러 개의 스레드가 시분할 방식으로 동시에 수행되는 것처럼 착각을 불러일으킴
- Parallelism(병렬성): 멀티 코어 환경에서 여러 개의 스레드가 실제로 동시에 수행됨
- Context Switching : 다른 태스크(프로세스, 스레드)가 시작할 수 있도록 이미 실행중인 태스크(프로세스, 스레드)를 멈추는 것

***

## 가비지 컬렉션
- 가비지 컬렉션 : 프로그램에서 더 이상 사용하지 않는 메모리를 자동으로 정리하는 것
- 이 기능을 가진 언어(혹은 엔진) : Java, C#, JavaScript 등
- 대표적인 가비지 컬렉션의 방법 : 트레이싱, 레퍼런스 카운팅
- 참고 링크 : https://developer.chrome.com/docs/devtools/memory-problems/memory-101/

### 1. 트레이싱
- 트레이싱 : 한 객체에 flag를 두고, 가비지 컬렉션 사이클마다 flag에 표시 후 삭제하는 mark and sweep 방법
- 객체에 in-use flag를 두고, 사이클마다 메모리 관리자가 모든 객체를 추적해서 사용중인지 아닌지를 표시(mark)
- 그 후 표시되지 않은 객체를 삭제(sweep)하는 단계를 통해 메모리를 해제

### 2. 레퍼런스 카운팅
- 레퍼런스 카운팅 : 한 객체를 참조하는 변수의 수를 추적하는 방법
- 객체를 참조하는 변수는 처음에는 특정 메모리에 대해 레퍼런스가 하나뿐
- 하지만 객체를 참조하고 있는 변수의 레퍼런스가 복사될 때마다 레퍼런스 카운트가 늘어남
- 객체를 참조하고 있던 변수의 값이 바뀌거나, 변수 스코프를 벗어나면 레퍼런스 카운트는 줄어듬
- 레퍼런스 카운트가 0이 되면, 그 객체와 관련한 메모리는 비울 수 있음

***

## 캐시 (웹 서비스에서)
- 링크 : https://aws.amazon.com/ko/caching/

### 1. 캐시 설명
- 캐시 : 많은 시간이나 연산이 필요한 작업의 결과를 저장해두는 것
- 일반적으로 일시적인(temporarily) 데이터를 저장하기 위한 목적으로 존재하는 고속의 데이터 저장공간
- 첫 작업 이후에 이 데이터에 대한 요청이 있을 경우, 데이터의 기본 저장공간에 접근할 때보다 더 빠르게 요청을 처리 가능
- 캐싱을 사용하면 이전에 검색하거나 계산한 데이터를 효율적으로 재사용 가능

### 2. 캐시의 일반적인 작동원리
- 캐시의 데이터는 일반적으로 RAM(Random Access Memory)과 같이 빠르게 액세스할 수 있는 하드웨어에 저장
- 소프트웨어 구성 요소와 함께 사용될 수도 있음
- 캐시는 기본 스토리지 계층(SSD, HDD)에 액세스하여 데이터를 가져오는 더 느린 작업의 요구를 줄임
- 속도를 위해 용량을 절충하는 캐시는 일반적으로 데이터의 하위 집합을 일시적으로 저장하여 영구적 데이터 보관소인 DB와 대조적

### 3. 캐시의 장점
- 애플리케이션 성능 개선
- 데이터베이스 비용 절감
- 백엔드 부하 감소
- 예측 가능한 성능
- 데이터베이스 핫스팟 제거
- 읽기 처리량 증가 (IOPS; Input/output operations per second. HDD, SSD 등의 컴퓨터 저장 장치의 성능 측정 단위)

### 4. 웹서비스에서 캐시가 적용되는 예시
- 클라이언트: HTTP 캐시 헤더, 브라우저
- 네트워크: DNS 서버, HTTP 캐시 헤더, CDN, 리버스 프록시
- 서버 및 데이터베이스: 키-값 데이터 스토어(e.g. Redis), 로컬 캐시(인-메모리, 디스크)
