# HTTP / 네트워크 기초

***

## 클라이언트-서버 아키텍처

### 1. 2티어 아키텍처
- 클라이언트-서버 아키텍처 (2티어 아키텍처) : 리소스가 존재하는 곳과 사용하는 곳을 분리시킨 것
- 서버 : 리소스가 존재하여 리소스를 제공하는 곳
- 클라이언트 : 리소스를 조회하여 사용하하는 곳
- 서버와 클라이언트는 요청과 응답을 주고받음

### 2. 3티어 아키텍처
- 3티어 아키텍처 : 2티어 아키텍처에 데이터베이스가 추가된 형태
- 데이터베이스 : 리소스를 저장하는 공간
- 서버 : 리소스를 전달하주는 역할만 담당

### 3. 프론트엔드와 벡엔드 개발자
- 프론트엔드 개발자 : 클라이언트가 시각적으로 상호작용 할 수 있는 앱 등을 개발
- 백엔드 개발자 : 사용자 눈에 보이지 않는 상품 정보를 API로 노출, 로그인/로그아웃, 권한 관리 등의 인증 다룸. 데이터베이스 시스템 설계를 하기도 함

## 클라이언트-서버 통신 그리고 API

### 1. 프로토콜
- 프로토콜(Protocol) : 서버와 클라이언트 사이 요청과 응답으로 통신하기 위해 필요한 통신 규약
- HTTP : 클라이언트와 서버가 HTTP라는 프로토콜을 이용해서 대화를 나누며, 이떄 주고받는 메세지를 HTTP 메세지라고 부름

- OSI 7 Layers : 해당 프로토콜이 어떤 계층(layer)에 속해 있는지 표시
  - ⑦ 응용 계층
  <img width="400" alt="스크린샷 2021-06-24 오전 10 41 26" src="https://user-images.githubusercontent.com/80403988/123189451-cea6e280-d4d8-11eb-862b-7ac800840313.png">
  
  - ⑥ 표현 계층
  - ⑤ 세션 계층
  - ④ 전송 계층
  <img width="400" alt="스크린샷 2021-06-24 오전 10 41 35" src="https://user-images.githubusercontent.com/80403988/123189463-d23a6980-d4d8-11eb-821e-1f237467fd75.png">
  
  - ③ 네트워크 계층
  - ② 데이터 링크
  - ① 물리

### 2. API
- API(Application Programming Interface) : 서버가 클라이언트에게 리소스를 잘 활용할 수 있도록 제공하는 인터페이스
- 인터페이스(Interface) : 의사소통이 가능하도록 만들어진 접점
- HTTP API 디자인을 위한 메소드 (MDN : HTTP 요청 메소드)
 
  <img width="500" alt="스크린샷 2021-06-24 오전 10 41 35" src="https://user-images.githubusercontent.com/80403988/123190851-44ac4900-d4db-11eb-85c0-5d587b8053b0.png">

***

## 브라우저의 작동 원리 (보이지 않는 곳)

### 1. URL과 URI
- URL(Uniform Resource Locator) : 네트워크 상에서 웹 페이지, 이미지, 동영상 등의 파일이 위차한 정보로 scheme, hosts, url-path로 구분
  - scheme : 통신 방식(프로토콜)을 결정하며 일반적으로 http(s)사용
  - hosts : 웹 서버의 이름이나 도메인, IP를 사용하며 주소를 나타냄
  - url-path : 웹 서버에서 지정한 루트 디렉토리, 웹 페이지, 이미지, 동영상 등이 위차한 경로와 파일명
- URI (Uniform Resource Identifier) : URL의 상위 개념으로 scheme, hosts, url-path뿐만 아니라 query, bookmark를 포함
  - query : 웹 서버에 보내는 추가적인 질문

<img width="750" alt="스크린샷 2021-06-24 오전 11 51 13" src="https://user-images.githubusercontent.com/80403988/123195083-868cbd80-d4e2-11eb-9868-b4afaf9038de.png">

<img width="400" alt="스크린샷 2021-06-24 오전 11 51 06" src="https://user-images.githubusercontent.com/80403988/123195090-88ef1780-d4e2-11eb-9c7b-5804a0fcf3e7.png">

### 2. IP와 포트
- IP 주소(Internet Protocol Address) : 네트워크에 연결된 특정 PC의 주소를 나타내는 체계
  - IPv4 : 닷(.)으로 구분된 네 덩이의 숫자 형식으로 구성된 주소체계. PC의 보급으로 할당할 수 있는 PC가 한계를 넘어서 현재는 IPv6 사용
  
  - ```localhost```, ```127.0.0.1``` : 현재 사용중인 로컬 PC
  - ```0.0.0.0```, ```255.255.255.255``` : broadcast address, 로컬 네트워크에 접속된 모든 장치와 소통하는 주소

- 포트(Port) : IP 주소에 진입할 수 있는 정해진 통로
  - 포트 번호는 0~65353까지 사용할 수 있으며, 그 중 0 ~ 1024 까지의 포트 번호는 주요 통신을 위한 규약에 따라 이미 정해짐
    - 22 : SSH
    - 80 : HTTP
    - 443 : HTTPS
    - 더 많은 포트 번호 : https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers
  - 리액트 예시 : ```localhost:3001``` - 3000번 포트를 사용중

### 3. 도메인과 DNS
- 도메인명(Domain name) : 웹 브라우저를 통해 특정 사이트를 진입할 때 IP 주소를 대신하여 사용하는 주소이며, 일정 기간 대여하여 사용
  - 코드스테이츠 도메인명 : codestates.com
  - 코드스테이츠의 IP 주소 : 3.34.153.168

- DNS (Domain Name System) : 도메인 이름과 IP주소를 매칭시키는 데이터베이스 시스템

### 4. 크롬 브라우저 에러 메세지
- 에러 메세지 링크 : chrome://network-errors
- 에러 문제 해결 링크 : https://support.google.com/chrome/answer/95669#zippy=%2Cpage-loading-error-codes-and-issues

<img width="800" alt="스크린샷 2021-06-24 오후 1 56 14" src="https://user-images.githubusercontent.com/80403988/123204991-125b1580-d4f4-11eb-8e54-f0ef49208d5c.png">

***

## HTTP Message
- HTTP(HyperText Transfer Protocol) : HTML과 같은 문서를 전송하기 위한 Application Layer 프로토콜
- HTTP 특징 : 특정 상태를 유지하지 않는 무상태성(Stateless) 지님
- HTTP Message : 클라이언트와 서버 사이 데이터가 교환되는 방식이며, 요청과 응답이 있음
- 요청(Requests) : 클라이언트가 서버에 보내는 메세지
- 응답(Responses) : 서버가 클라이언트에 보내는 메세지

<img width="700" alt="스크린샷 2021-06-24 오후 3 12 13" src="https://user-images.githubusercontent.com/80403988/123211661-b47ffb00-d4fe-11eb-84b4-1b35af62067c.png">

### 1. 요청과 응답의 구조
- ① Start Line / Status Line : 요청 / 응답의 상태를 나타내며 첫 줄에 위치
- ② HTTP Headers : 요청을 지정하거나, 메세지에 포함된 본문을 설명하는 헤더 집합
- ③ Empty Line : 헤더와 본문을 구분하는 빈 줄
- ④ Body : 요청/응답과 관련된 데이터나 문서. 요청/응답 유형에 따라 선택적으로 사용
- 헤드(Head) : ① + ②
- payload : ④

### 2. 요청(Request)의 구조
- Start Line : 세 가지 요소가 있음 (메소드 - URI - Version)
  - ① 수행할 작업(GET, PUT, POST등)이나 방식(HEAD or OPTIONS)을 설명하는 HTTP 메소드를 나타냄

  - ② 요청 대상(일반적으로 URL이나 URI) 또는 프로토콜, 포트, 도메인의 절대 경로는 요청 컨텍스트에 의해 작성됨
    - Origin 형식 : ```?```와 쿼리 문자열이 붙는 절대 경로이며 POST, GET, HEAD, OPTIONS 등의 메소드와 함께 사용
    ```POST / HTTP 1.1```
    ```GET /background.png HTTP/1.0```
    ```HEAD /test.html?query=alibaba HTTP/1.1```
    ```OPTIONS /anypage.html HTTP/1.0```
  
    - Absolute 형식 : 완전한 URL 형식으로 프록시에 연결하는 경우 대부분 GET 메소드와 함께 사용
    ```GET http://developer.mozilla.org/en-US/docs/Web/HTTP/Messages HTTP/1.1```

    - Authority gudtlr : 도메인 이름과 포트 번호로 이루어진 URL의 authority component이며 HTTP 터널 구축시 ```CONNECT```와 함께 사용
    ```CONNECT developer.mozilla.org:80 HTTP/1.1```

    - Asterisk 형식 : ```OPTIONS```와 함께 별표(*) 하나로 서버 전체 표현
    ```OPTIONS * HTTP/1.1```

  - ③ HTTP 버전은 메세지의 다른 구조를 결정함

- Headers : 요청의 Headers는 기본 구조 따르며 대소문자 구분 없는 문자열과 콜론(:) 값을 입력 (name:value)
  - General headers : 메세지 전체에 적용됨
  - Request headers : User-Agent, Accept-Type, Accept-Language과 같은 헤더는 요청을 보다 구체화
  - Entity headers : Content-Length와 같은 헤더는 body에 적용되며 body가 비어있는 경우, entity headers는 전송되지 않음

  <img width="600" alt="스크린샷 2021-06-24 오후 3 12 25" src="https://user-images.githubusercontent.com/80403988/123211684-bfd32680-d4fe-11eb-9e78-c201532a858c.png">

- Body (Optional)
  - 모든 요청에 body가 필요하지는 않으며 GET, HEAD, DELETE, OPTIONS처럼 서버에 리소스를 요청하는 경우에는 본문이 필요없음
  - POST나 PUT과 같은 일부 요청은 데이터를 업데이트 하기 위해 사용
  - Body의 종류
    - Single-resource bodies(단일-리소스 본문) : 헤더 두 개(Content-Type과 Content-Length)로 정의된 단일 파일로 구성
    - Multiple-resource bodies(다중-리소스 본문) : 여러 파트로 구성된 본문에서는 각 파트마다 다른 정보를 지님

### 3. 응답(Responses)의 구조
- Status Line : 3가지 정보 포함
  - ① 현재 프로토콜의 버전 (HTTP/1.1)
  - ② 상태 코드(Status) : 요청 결과를 나타냄 (200, 302, 404 등)
  - ③ 상태 텍스트 (Reason Phrase) : 상태 코드에 대한 영어로 된 설명
  ```HTTP/1.1 404 Not Found.```

- Headers : 요청 헤더와 동일한 구조를 가지며 대소문자 구분 없는 문자열과 콜론(:), 값을 입력 (name:value)
  - General headers : 메세지 전체에 적용됨
  - Response headers : Vary, Accept-Ranges와 같이 상태 줄에 넣기에는 공간이 부족했던 추가 정보를 제공
  - Entity headers : Content-Length와 같은 헤더는 body에 적용되며, body가 비어있는 경우 entity headers는 전송되지 않음

  <img width="600" alt="스크린샷 2021-06-24 오후 3 28 29" src="https://user-images.githubusercontent.com/80403988/123213675-3e30c800-d501-11eb-8db3-05e9f33ec11a.png">

- Body (Optional)
  - 모든 요청에 body가 필요하지는 않으며 201, 204와 같은 상캐도르를 가지는 응답에는 본문이 필요없음
  - Single-resource bodies(단일-리소스 본문)
    - 길이가 알려진 단일-리소스 본문은 두 개의 헤더(Content-Type, Content-Length)로 정의
    - 길이를 모르는 단일 파일로 구성된 단일-리소스 본문은 Transfer-Encoding이 chucked로 설정되어 있으며, 파일은 chuck로 나뉘어 인코딩됨
  - Multiple-resource bodies(다중-리소스 본문) : 서로 다른 정보를 담고 있는 body

### 4. 읽어봐야 할 문서
- MDN HTTP 요청 메소드 : https://developer.mozilla.org/ko/docs/Web/HTTP/Methods
- MDN HTTP 메세지 : https://developer.mozilla.org/ko/docs/Web/HTTP/Messages
- MDN HTTP 상태 코드 : https://developer.mozilla.org/ko/docs/Web/HTTP/Status
- MDN MIME Type (Content-Type 설명) : https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/MIME_types
- 브라우저 동작 : https://d2.naver.com/helloworld/59361

***

## 브라우저 작동 원리 (보이는 곳)

### SPA를 만드는 기술 : AJAX

- Dynamic Web Page의 등장
  - 과거에는 페이지 전환시 필요한 부분 뿐만 아니라 페이지 전체를 로딩
  - 서비와 자유롭게 통신할 수 있도록 XHR(XMLHttpRequest) 등장
  - 페이지 깜빡임 없이 작동하는 단순한 Web Page가 아닌 Web App의 등장 (JavaScript와 DOM 이용)
- AJAX : Asynchronous JavaScript and XML

### SSR과 CSR

- SSR (Server Side Rendering)
  - SSR : 웹 페이지를 브라우저에서 렌더링하는 대신에 서버에서 랜더링
  - 과정 : 브라우저가 서버의 URI로 ```GET``` 요청 보냄 → 서버는 정해진 웹 페이지 파일을 브라우저로 보냄 → 파일이 브라우저에 도착하면 완전히 렌더링
  - 특징 : 서버에서 웹 페이지를 완전히 렌더링 한 후에 브라우저로 보냄
  - 유용한 경우 : SEO가 우선순위인 경우, 단일 파일의 용량이 작은 경우, 웹 페이지가 사용자와 상호작용이 적은 경우

- CSR (Client Side Rendering)
  - CSR : SSR과 반대로 서버측이 아닌 클라이언트(웹 브라우저)에서 페이지 랜더링
  - 과정 : 브라우저가 서버로 요청 → 서버는 웹 페이지의 골격이 될 단일 페이지를 클라이언트에게 보냄 (웹페이지 + JavaScript 파일) → JS 파일은 브라우저에서 웹 페이지를 완전히 렌더링된 페이지로 바꿈
  - 웹 페이지에 필요한 내용이 데이터베이스에 저장된 경우 → API 사용하여 데이터베이스에 저장된 데이터 가져옴
  - 특징 : 브라우저가 다른 경로로 이동하면 서버가 웹 페이지를 다시 보내지 않고, 브라우저는 브라우저가 요청한 경로에 따라 페이지 다시 렌더링
  - 유용한 경우 : SEO가 우선순위가 아닌 경우, 사이트에 풍부한 상호 작용이 있는 경우, 웹 애플리케이션 제작시 빠른 동적 렌더링을 제공해야할 경우

- 차이점 : 페이지가 렌더링되는 위치이며
  - SSR은 서버에서 페이지를 렌더링하고, CSR은 브라우저(클라이언트)에서 페이지를 렌더링
  - 브라우저는 사용자가 다른 경로를 요청할 때마다 페이지를 새로고침 하지 않고, 동적으로 라우팅을 관리

### CORS (Cross-Origin Resource Sharing)
-
 Browser Security Model
  - CORS
  - XSS
  - CSRF
  