# 알고리즘 문제의 접근법과 학습법

***

## 알고리즘 문제 접근법

- 프로그래밍 없이도 문제를 풀 수 있어야 함 (한국어, 영어)

- 문제를 분석하기 전까지는 코드를 작성하지 말기 (코딩은 짧은 시간에 완성됨)

  - 종이와 펜으로 우선 문제 푸는 것을 추천

  - 코드부터 작성하면 방향이 잘못되더라도 아까워서 코드를 날려버리기 어려워 꼬일 수 있음

- 문제의 크기를 알아야 함

- 아아디어가 없으면 먼저 완전 탐색으로 풀기

***

## 문제 풀이 과정

- 문제를 순서대로 풀 수 있어야 하고 문제의 시작과 끝을 알아야 함

- 문제를 최대한 작은 단위로 쪼개는 연습을 해야 함 (Divide and Conquer)

- 막힐 때는 조건을 어떻게 바꿀지 고민해보기

- 배열에서 정렬
  - arr.sort 사용하기 // arr.sort( (a,b) => a-b)

  - merge sort, quick sort도 가치 있음

  - 정렬은 천만개까지 괜찮음

***

## 공부법

- 재귀는 필수

- 레퍼런스 코드 손으로 쓰면서 이해해보기 (어려운 문제는 정답을 보고 이해하는 것도 공부법)

- 지속적인 반복 학습으로 익숙해지기
  - 순열, 조합 등 수학들은 템플릿화가 잘 되어있고 코드를 우려먹을 수 있음

- 참고 사이트 : geeksforgeeks 

***

## 빈출 유형

### 1. 빈출 유형 3가지
- backtracking
- divide and conquer (분할 정복)
- Graph Algorithm

### 2. 외울 내용들
- GCD
- 순열/조합
- 정렬은 sort 메소드 사용
- DFS(재귀), BSF(큐)
- 분할정복, DP : Geeksforgeeks 통해 케이스 스터디 필요

***

## 코딩테스트 난이도
- 일반적으로 기준 : 프로그래머스 기준 레벨 3, 해커랭크 기준 medium 정도 실력이면 괜찮음
- 어렵게 내는 기업의 기준 (ex. 카카오) : 프로그래머스 3.5~4 단계, 해커랭크 hard
- 코드스테이츠 Toy 문제는 프로그래머스 3단계 수준
- 코딩 테스트 환경에 따라 복사-붙여넣기가 안 되는 곳도 있음

***

## 공간복잡도와 시간복잡도

- 문제의 크기에 따라 시간복잡도와 공간복잡도 고려

- 오늘날 공간복잡도는 크게 중요하지 않음

### 1. 공간복잡도

- 단위에 대한 설명
  - Kilo : 1,000 - 천

  - Mega : 1,000,000 (kilo x 1000) - 백만

  - Giga : 1,000,000,000 (Mega x 1000) - 십업

  - Tera : 1,000,000,000,000 (Giga x 1000) - 조

  - 1,000,000,000,000 : 쉼표 왼쪽을 읽으면 천, 백만, 십업, 조가 됨

- KB, MB, GB
  - KB = 1000 byte

  - MB = 1000K = 100만 byte

  - GB = 1000M = 10억 byte

- JavaScript의 데이터 
  - JavaScript의 데이터 1개 크기 : 8byte

  - JavaScript의 데이터 100만개 크기 : 8 Megabyte

- 코딩테스트의 공간복잡도
  - 코딩테스트에서 공간복잡도를 정해주기도 함 (128MB, 256MB, 512MB)

  - 자료가 1000만개(80MB)부터는 공간복잡도를 고려해서 코드를 전부 다 표현하면 안됨

### 2. 시간복잡도

- 시간복잡도 기준 : 1억 === 1초

- N의 크기에 따라 시간복잡도를 고려해서 코드 작성하기

  - 코딩테스트에서 무조건 효율적인 코드를 작성하려고 하면 시험 시간이 모자람

  - O(N^3)이라도 조건에 따라서 괜찮음 (N=500이면, N^3 == 1.25억이라서 괜찮음)

  - O(N)은 for 반복문, O(N^2)는 이중 for 반복문

- 순열과 조합은 10~11개 이상 돌릴 수 없음 : 1초 이상의 제한이 있는 경우 스택오버플로우

### 3. 1초가 걸리는 입력의 크기 (암기 권장)
- O(N) : 100,000,000
- O(NlogN) : 5,000,000
- O(N^2) : 10,000
- O(N^3) : 500
- O(2^N) : 26
- O(N!) : 11
