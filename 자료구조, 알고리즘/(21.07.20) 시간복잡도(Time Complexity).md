# 시간복잡도 (Time Complexity)
- 효율적인 알고리즘 : 입력값이 커짐에 따라 증가하는 시간의 비율을 최소화한 알고리즘
- 효율적인 알고리즘을 고민한다는 것이 곧 시간복잡도를 고민하는 것


## Big-O 표기법

- 시간 복잡도 표기법

  - Big-O(빅-오) : 시간 복잡도를 최악의 경우에 대하여 나타냄 (최대 이 정도 시간까지 걸릴 수 있다)

  - Big-Ω(빅-오메가) : 시간 복잡도를 최선의 경우에 대하여 나타냄 (최소 특정 시간 이상이 걸린다)

  - Big-θ(빅-세타) : 시간 복잡도를 중간(평균)의 경우에 대하여 나타냄 (이 정도 시간이 걸린다)

- Big-O 표기법이 가장 자주 사용되는데, 최악의 경우도 고려하여 대비하는 것이 바람직하기 때문
- "입력값의 변화에 따라 연산을 실행할 때, 연산 횟수에 비해 시간이 얼마만큼 걸리는가?"를 표기


### O(1)
- O(1)는 constant complexity라고 하며, 입력값이 증가하더라도 시간이 늘어나지 않음
- 입력값의 크기과 상관없이 즉시 출력값 얻어낼 수 있음

### O(n)
- O(n)은 linear complexity라고 부르며, 입력값이 증가함에 따라 시간 또한 같은 비율로 증가하는 것

### O(long n)
- O(log n)은 logarithmic complexity라고 부르며 Big-O표기법중 O(1) 다음으로 빠른 시간 복잡도를 가짐
- BST가 O(log n)에 해당하는 예시이며, 원하는 값을 탐색할 때 노드를 이동할 때마다 경우의 수가 절반으로 줄어듬

### O(n2)
- O(n2)은 quadratic complexity라고 부르며, 입력값이 증가함에 따라 시간이 n의 제곱수의 비율로 증가하는 것을 의미
- n3과 n5 도 모두 O(n2)로 표기 (n이 커지면 커질수록 지수가 주는 영향력이 점점 퇴색되기 때문)

### O(2n)
- O(2n)은 exponential complexity라고 부르며 Big-O 표기법 중 가장 느린 시간 복잡도를 가짐
- 재귀로 구현하는 피보나치 수열은 O(2n)의 시간 복잡도를 가진 대표적인 알고리즘

***

## 데이터 크기에 따른 시간 복잡도
- 시간제한과 주어진 데이터 크기 제한에 따른 시간 복잡도를 어림잡아 예측해보기
- 입력 데이터 n이 1,000,000보다 작은 수일 때 O(n) 혹은 O(nlogn)의 시간 복잡도를 가지도록 예측하여 프로그램을 작성하기
- 만약 n ≤ 500 으로 입력이 제한된 경우에는 O(n3)의 시간 복잡도를 가질 수 있다고 예측 가능

