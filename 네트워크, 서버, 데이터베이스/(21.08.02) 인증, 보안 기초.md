
## HTTPS 프로토콜
- HTTPS (Hyper Text Transfer Protocol Secure Socket layer) : HTTP over SSL(TLS), HTTP over Secure라고 부르기도 함
- HTTP 프로토콜에서 암호화 통한 보안 추가
- HTTP 요청을 SSL 혹은 TLS라는 알고리즘을 이용해, HTTP 통신을 하는 과정에서 내용을 암호화하여 데이터를 전송하는 방법
- 요청을 누구나 볼 수 있는 HTTP보다 상대적으로 안전한 방법이고, 데이터 제공자의 신원을 보장받을 수 있음

### 1. 중간자 공격
- 중간자 공격 : 요청 및 응답을 중간에서 가로채는 공격이며, 데이터를 탈취 및 변조하여 다시 전송
- 클라이언트는 서버에 요청하고 응답을 받으며 데이터 제공자가 제공해준 데이터를 사용하기 때문에 중간자 공격에 취약

### 2. 비대칭 키 암호화
- HTTPS 프로토콜의 특징 중 하나는 암호화된 데이터를 주고받는 것
- 중간에 인터넷 요청이 탈취되더라도 복화하 하기 전까지는 그 내용을 알아볼 수 없음
- 다른 키 한 쌍으로 암호화와 복호화 가능 : A키로 암호화 한다면 한 쌍인 B키로 복호화 해야함
- 한 쌍의 키 중에서 하나는 비밀로 숨겨두고 하나는 클라이언트에 공개 (공개 키는 알고리즘이 복잡해 통신의 초창기에서만 사용)

### 3. 인증서 (Certificate)
- 데이터 제공자 신원 보장 : 데이터를 보낸 서버가 맞는지 인증
- 도메인 종속 : 인증서에 서버 도메인 관련 내용 포함
- 서버는 인증서와 함께 응답 전송 → 클라이언트는 인증서에 작성된 도메인과 응답 객체에 작성된 도메인 비교 → 일치하면 데이터를 제공해준 서버가 맞다는 것 확인
- 그러나 해커가 요청 정보를 탈취해 정보를 훔칠 수 있음
- 브라우저는 인증서에서 해당 인증서를 발급한 CA 정보를 확인하고 인증된 CA가 발급한 인증서가 아니라면 화면에 경고창을 띄워 경고

### 4. CA (Certificate Authority)
- 공인 인증서 발급 기관
- 브라우저는 신뢰하는 발급 기관을 가지고 있음

<img width="750" alt="스크린샷 2021-08-03 오후 11 15 34" src="https://user-images.githubusercontent.com/80403988/128031516-a52cc909-0d8e-4c47-8826-acd9607dc997.png">

***

## Hashing
- 암호화(encryption) : 일련의 정보를 임의의 방식을 사용해 다른 형태로 변환하여 해당 방식에 대한 정보를 소유한 사람을 제외하고 이해할 수 없도록 '알고리즘'을 이용해 정보를 관리하는 과정

- Hashing : 어떤 문자열에 '임의의 연산'을 적용하여 다른 문자열로 변환하는 것
  - 모든 값에 대해 해시 값을 계산하는데 오래걸리지 않아야 함
  - 최대한 해시 값을 피해야 하며, 모든 값을 고유한 해시 값을 가짐
  - 아주 작은 단위의 변경이라도 완전히 다른 해시 값을 가져야 함

## Salt
- Salt : 암호화해야 하는 값에 어떤 별도의 값을 추가하여 결과를 변형하는 것

### 1. Salt 사용 이유
- 암호화만 해놓는다면 해시된 결과가 늘 동일
  - 해시된 값과 원래 값을 테이블(레인보우 테이블)로 만들어서 decoding 해버리는 경우도 생김
- 원본값에 임의로 약속된 '별도의 문자열'을 추가하여 해시를 진행한다면, 기존 해시값과 전혀 다른 해시값이 반환되어 알고리즘이 노출되더라도 원본값을 보호할 수 있도록 하는 안전 장치
- 기존 방식 : 암호화 하려는 값 -> hash값
- salt 사용 : 암호화 하려는 값 + salt용 값 -> hash 값

### 2. 주의점
- Salt는 유저와 패스워드 별로 유일한 값을 가져아 함
- 사용자 계정을 생성할 때와 비밀번호를 변경할 때 마다 새로운 임의의 Salt를 사용해서 해싱해야 함
- Salt는 절대 재사용하지 말아야 함
- Salt DB의 유저 테이블에 같이 저장되어야 함

***

## Cookie
- Cookie : 웹사이트에서 서버가 일방적으로 클라이언트에 전달하는 작은 데이터이자 서버가 웹 브라우저에 정보를 저장하고 불러올 수 있는 수단
- HTTP는 무상태성(stateless)인데 cookie를 통해서 상태 유지
- 해당 도메인에 쿠기가 존재하면 브라우저는 도메인에게 http 요청 시 쿠키를 함께 전달

### 1. 쿠키 옵션
- Domain : 서버와 요청의 도메인이 일치하는 경우 쿠키 전송
- Path : 서버와 요청의 세부경로가 일치하는 경우 쿠기 전송
- MaxAge or Expires : 쿠키의 유효기간 설정
- HttpOnly : 스크립트의 쿠키 접근 가능 여부 결정 (XSS 공격 방어)
  - 쿠키는 경우에 따라 script 태그로 접근 가능해서 HttpOnly 옵션으로 script 태그의 접근 차단 가능
- Secure : HTTPS 프로토콜에서만 쿠키 전송 여부 결정
- SameSite : CORS 요청의 경우 옵션 및 메서드에 따라 쿠키 전송 여부 결정
  - Lax : GET 메소드 요청만 쿠키 요청 가능
  - Strict : Cross-Origin이 아닌 same-site 인 경우에만 쿠키 전송 가능
  - None : 모든 메소드 요청에 대한 쿠키 전송 가능 (Secure 쿠키 옵션 필요)

### 2. Cookie 전달 방법
- 서버 → 클라이언트
  ```
  Set-Cookie: UserId=kimcoding path=/expire=...
  Set-Cookie: email=...path/expire=...
  ```
- 클라이언트 → 서버
  ```
  Cookie: UserId=kimcoding
  Cookie: email=...
  ```

<img width="500" alt="스크린샷 2021-08-03 오후 11 16 43" src="https://user-images.githubusercontent.com/80403988/128031617-aa4a98a7-21cf-4fbb-93a0-5eeaa0a4daaf.png">


## 세션기반 인증 (Session-based Authentication)
- 서버가 Client에 유일하고 암호화된 ID를 부여
- 중요 데이터는 서버에서 관리

### 1. 세션
- 세션 : 사용자가 인증에 성공한 상태를 뜻함 (덕분에 로그인 상태를 유지)
- 인증에 성공했음을 서버가 알고 그것을 클라이언트가 증명할 수 있다면 매 작업마다 로그인할 필요 없음
- 인증에 따라 리소스 접근 권한이 달라짐

### 2. 세션 저장
- 서버의 저장소에 세션을 저장하는데 주로 in-memory(JS 객체) 또는 세션스토어(redis등 NoSQL DB)
- 세션이 만들어지면 각 세션을 구분할 수 있는 세션 아이디도 만들어져 클라이언트에 전달됨 (세션 성공 증명 수단)
- 웹사이트에 로그인 유지 수단으로 쿠키를 사용하며, 쿠키에는 서버에서 발급한 세션 아이디 저장

### 3. 세션기반 인증 과정

<img width="850" alt="스크린샷 2021-08-03 오후 11 17 20" src="https://user-images.githubusercontent.com/80403988/128031656-f1304976-1c5b-44f5-ba60-59ed0b760081.png">

- 그림1 : 사용자가 아이디와 비밀번호로 서버에 로그인 시도 (헤싱 없이 그냥 전달되며 그래서 HTTPS가 중요)
- 그림2 : 로그인 암호 헤싱 후 DB 정보와 비교한 뒤, 회원이 맞으면 세션 생성 후 서버의 세션스토어에 저장
- 그림3 : 서버스토어에서 세션 정보를 반환
- 그림4 : 세션 정보(세션 아이디)를 클라이언트에 쿠키에 담아서 전달
- 그림5 : 쿠키를 통해 유효한 세션 정보를 서버로 전달
- 그림6 : 세션이 존재하는지 세션스토에서 확인
- 그림7,8 : 세션이 유효하다면 요청 수행하고 클라이언트에 반응 전달

### 4. 로그아웃
- 서버의 세션 정보 삭제하기
- 클라이언트의 쿠키 갱신 : 서버가 클라이언트의 쿠키를 임의로 삭제할 수 없지만, set-cookie로 세션 아이디 키값을 무효한 값으로 객신
- 주의사항 : 세션이 담긴 쿠키가 탈취되면 서버는 해당 요청을 인증된 사용자로부터 왔다고 인식함 → 공공 PC의 로그아웃 필수

***

## 여러 가지 공격들
- SQL Injection
- XSS
- CSRF (Cross Site Request Forgery)

### 1. CSRF 
- CSRF : 다른 오리진(cross-site)에서 유저가 보내는 요청(request)를 조작(forgery)하는 것
- 해커가 직접 데이터를 접근할 수 없음 (다른 오리진이기 때문)

### 2. CSRF 공격을 하기 위한 조건
- 쿠키를 사용한 로그인 : 유저가 로그인 했을 떄 쿠키로 해당 유저를 알 수 있어야 함
- 예측할 수 있는 요청/parameter를 가지고 있어야 함 : request에 해커가 모를 수 있는 정보가 담겨있으면 안됨

### 3. CSRF 방어 조건
- CSRF 토큰 사용 : 서버측에서 공격을 보호하기 위해 유저의 브라우저와 앱에만 제공
- Same-site cookie 사용하기 : 같은 도메인에서만 세션/쿠키를 사용할 수 있음

