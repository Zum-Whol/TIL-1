# 네티워크 심화

***

## 인터넷 프로토콜

<img width="500" alt="스크린샷 2021-08-09 오전 11 30 36" src="https://user-images.githubusercontent.com/80403988/128654926-6d12784f-43a8-4d7d-9645-737b52e3c88d.png">

***

## IP와 IP Packet

### 1. IP Packet
- IP : 지정한 IP 주소에 패킷(Packet)이라는 통신 단위로 데이터 전달
- IP Packet (pack + bucket : 소포) : 출발지 IP, 목적지 IP와 같은 정보가 포함
- 패킷 단위로 전송하여 복잡한 인터넷 망 사이에서도 IP 주소를따라 정확한 목적지로 데이터 전달
- 서버와 클라이언트 모두 패킷 단위로 전달

<img width="400" alt="스크린샷 2021-08-09 오전 11 28 46" src="https://user-images.githubusercontent.com/80403988/128654814-4d651f93-ab88-4c1b-8eec-8643e442f5e1.png">

### 2. IP Packet의 한계
- 비연결성 : 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송 가능 (서버 상태 파악 불가능)
- 비신뢰성 : 중간에 패킷이 사라질 수 있고 패킷의 순서를 보장할 수 없음 (각 패킷들이 서로 다른 노드들 통해 전달)

***

## TCP vs UDP
- TCP (Transmission Control Protocol) 전송 제어 프로토콜
- UDP (User Datagram Protocol)
- 인터넷 계층에 속하는 IP보다 높은 전송 계층에 속한 TCP로 IP의 한계 보완 가능

<img width="510" alt="스크린샷 2021-09-13 오후 5 24 41" src="https://user-images.githubusercontent.com/80403988/133060477-6f7da4db-c295-464e-9f18-814a4460f69e.png">

### 1. 데이터 전달 과정

<img width="600" alt="스크린샷 2021-08-09 오전 11 32 40" src="https://user-images.githubusercontent.com/80403988/128654999-9d4427e1-313c-4842-b09b-07d9b50fa089.png">

- 먼저 HTTP 메시지가 생성되면 Socket 라이브러리를 통해 전달
- 네트워크 소켓(Socket) : 프로그램이 네트워크에서 데이터를 송수신하도록 네트워크 환경에 연결하기 위한 연결부
- 그리고 IP 패킷을 생성하기 전 TCP 세그먼트를 생성
- 생성된 TCP/IP 패킷은 LAN 카드와 같은 물리적 계층을 지나기 위해 이더넷 프레임 워크에 포함되어 서버로 전송

### 2. TCP/IP 패킷
  - TCP 세그먼트 : 출발지 PORT, 목적지 PORT, 전송 제어, 순서, 검증 정보 등 (IP 패킷 정보 보완)
  - IP 세트먼트 : 출발지 IP, 목적지 IP 등
 
 <img width="400" alt="스크린샷 2021-08-09 오전 11 32 46" src="https://user-images.githubusercontent.com/80403988/128655008-ced75e77-9614-4ff3-958d-6005b183cfbe.png">

### 3. TCP 특징
- 연결 지향 : TCP 3 way handshake (가상 연결)

<img width="526" alt="스크린샷 2021-09-13 오후 5 10 09" src="https://user-images.githubusercontent.com/80403988/133060525-cc37bcbb-dbe5-4a3f-ac84-8a00cd9b7b02.png">

  - SYN : Syncronize / ACK : Acknowledgment

  - 클라이언트는 서버에 접속을 요청하는 SYN 패킷을 보냄

  - 서버는 SYN요청을 받고 클라이언트에게 요청을 수락한다는 ACK 와 SYN가 설정된 패킷을 발송

  - 서버에게 ACK을 보내면 이후 연결이 성립되며 데이터를 전송할 수 있음

  - 만약 서버가 꺼져있다면 클라이언트의 SYN에 대한 서버의 응답이 없기 떄문에 클라이언트가 데이터를 보내지 않음

  - 현재에는 최적화가 이루어져 3번 ACK을 보낼때 데이터를 함께 보내기도 함

- 데이터 전달 보증 : TCP는 데이터 전송이 성공적으로 이루어진다면 이에 대한 응답을 돌려주어 IP 패킷의 비연결성 보완

- 순서 보장 : 패킷이 순서대로 도착하지 않는다면 TCP 세그먼트에 있는 정보를 토대로 다시 패킷 전송을 요청하여 비신뢰성 보완

### 4. UDP 특징
- 구조 : IP 프로토콜에 PORT, 체크섬 필드 정보만 추가된 단순한 프로토콜
- 체크섬(checksum) : 중복 검사의 한 형태로 오류 정정을 통해 공간(전자 통신)이나 시간(기억 장치) 속에서 송신된 자료의 무결성을 보호하는 단순한 방법
- 비 연결지향 : 신뢰성은 낮지만 3 way handshake 방식을 사용하지 않기 때문에 TCP와 비교해 빠른 속도를 보장
- HTTP3는 UDP를 사용하며 이미 여러 기능이 구현된 TCP보다는 하얀 도화지처럼 커스터마이징이 가능

***

## HTTP의 특징

- HTTP/1.1, HTTP/2 : TCP 기반
- HTTP/3 : UDP 기반

### 1. 클라이언트 서버 구조
- 클라이언트 서버 구조 : 클라이언트가 서버에 요청을 보내면 서버는 그에 대한 응답 보냄
- 무상태 프로토콜 (Stateless) : 서버가 클라이언트의 상태를 보존하지 않음

### 2. 무상태 프로토콜 (Stateless)
- 상태 유지의 경우 (Stateful)
  - 데이터가 서버에 있기 때문에 항상 같은 서버를 유지해야 함
  - 서버에 장애가 생기면 상태정보가 다 날아가므로 처음부터 다시 서버에 재요청해야함

- 무상태 유지 (Stateless)
  - 상태가 없다기 보다는 상태를 저장하지 않음
  - 클라이언트가 이미 필요한 데이터를 다 담아서 보냄
  - 서버 확장성 높음 : 응답 서버를 쉽게 바꿀 수 있어서 갑자기 서버 대거 투입 가능
  - 로그인이 필요한 경우 무상태성을 보완하기 위해 쿠키, 서버 세션, 토큰 등을 이용ㄴ

### 3. 비연결성 (Connectionless)
- 연결을 유지하는 HTTP 모델의 경우 (Connection Oriented)
  - TCP/IP의 경우 기본적으로 연결을 유지
  - 클라이언트가 요청을 보내지 않더라도 계속 연결을 유지해야 하고 서버 자원이 소모됨
- 연결은 유지하지 않는 HTTP 모델의 경우 (Conectionless)
  - HTTP 1.0 기준으로, HTTP는 연결을 유지하지 않는 모델 (기본 모델)
  - 실제로 요청을 주고 받을 때만 연결을 유지하고 응답을 주고나면 TCP/IP 연결을 음
  - 트래픽이 많지 않고 빠른 응답을 제공할 수 있는 경우 비연결성의 특징은 효율적 (단순 검색 등)
  - 트래픽이 많고, 큰 규모의 서비스를 운영할 때에는 비연결성은 한계

### 4. 비연결성의 한계와 극복
- HTTP 초기에는 연결과 종료를 반복하며 시간을 낭비
- TCP/IP 연결을 새로 맺어야 해서 3 way handshakes 시간 추가
- 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, css, 이미지 등 수 많은 자원 다운로드
- 현재 HTTP 지속 연결(Persistent Connections)로 문제를 해결
- HTTP/2, HTTP/3에서 더 최적화 (HTTP2에서는 비연결성이 무의미하게 됨)

<img width="627" alt="스크린샷 2021-09-13 오후 6 31 47" src="https://user-images.githubusercontent.com/80403988/133060622-065d3864-ae34-4670-9a5b-c8d7af754e12.png">

***

## 표현 헤더 (Representation Headers)

### 1. 헤더와 바디

- HTTP 바디 : 데이터 메시지 본문(Message body = 페이로드:payload)을 통해서 표현 데이터를 전달
- 표현(Representation) : 요청이나 응답에서 전달할 실제 데이터
- 표현 헤더 : 표현 데이터를 해석할 수 있는 정보를 제공 (데이터 유형, 길이, 압축 정보)

### 2. 헤더
- 형식 : <field-name> : <field-value> → field-name은 대소문자 구분 없음
- HTTP 전송에 필요한 부가정도 담기 위해 사용
- 표준 헤더 : https://en.wikipedia.org/wiki/List_of_HTTP_header_fields

### 3. 표현 헤더 양식 예시
- Counter-type : 표현 데이터의 형식으로 미디어 타입/문자 인코딩
  - Text/html; charset=utf8
  - application/json
  - image/png
  - type 링크 : https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Content-Type
  - MIME 링크 : https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/MIME_types

- Content-Encoding : 표현 데이터 인코딩으로 표현 데이터 압축을 위해 사용하며 데이터 압축 방식 표현
  - gzip
  - deflate
  - identity
  - 링크 : https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Content-Encoding

- Content-Language : 표현 데이터의 자연 언어
  - ko
  - en
  - en-US
  - 링크 : https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Content-Language

- Content-Length : 표현 데이터의 길이
  - Transfer-Encoding(전송 코딩) 사용시 Content-Length를 사용하면 안됨
  - length 링크 : https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Content-Length
  - encoding 링크 : https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Transfer-Encoding

### 4. 요청(Request)에서 사용되는 헤더
- From: 유저 에이전트의 이메일 정보
- Referer: 이전 웹 페이지 주소
- User-Agent: 유저 에이전트 애플리케이션 정보
- Host: 요청한 호스트 정보(도메인) (필수 정보)
- Origin: 서버로 POST 요청을 보낼 때, 요청을 시작한 주소를 나타냄
- Authorization: 인증 토큰(e.g. JWT)을 서버로 보낼 때 사용하는 헤더

### 5. 응답(Response)에서 사용되는 헤더
- Server: 요청을 처리하는 ORIGIN 서버의 소프트웨어 정보
- Date: 메시지가 발생한 날짜와 시간
- Location: 페이지 리디렉션
- Allow: 허용 가능한 HTTP 메서드 (예시 - Allow: GET, HEAD, PUT)
- Retry-After: 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간

### 6. 콘텐츠 협상 헤더 (요청시에만 사용)
- Accept : 클라이언트가 선호하는 미디어 타입
- Accept-Charset : 클라이언트가 선호하는 문자 인코딩
- Accept Encoding : 클라이언트 선호 압축 인코딩
- Accept Language : 클라이언트가 선호하는 자연어
- 링크 : https://developer.mozilla.org/ko/docs/Web/HTTP/Content_negotiation

- 협상과 우선순위 : Qualtity Values(q) 사용
  - q의 범위는 0~1이며 클수록 높은 우선순위 (생략의 경우 1)
  - 코드 예시 : Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8 (ko-KR은 q=1 값이 생략됨)

***

## 웹 캐시
- 캐시 : 데이터나 값을 미리 복사해 놓는 임시 장소

### 
- 캐시 없을 경우 네트워크를 통해 같은 데이터를 또 다운받아야 함
- 용량이 클 수록 비용이 커지고 브라우저의 로딩속도가 느려짐

- 캐시에 데이터를 미리 복사해 놓으면 계산이나 접근 시간 없이 더 빠른 속도로 데이터에 접근
- 브라우저에 캐시를 저장할 땐 헤더에 cache-control 속성을 통해 캐시가 유효한 시간을 지정할 수 있음

### 캐시의 유효기간
- 클라이언트의 첫 번째 요청에 대한 응답으로 캐시를 보내면 두 번째 요청에서는 캐시를 우선 조회
- 유효한 캐시라면 캐시에서 데이터 가져옴
- 유효기간이 지난 캐시를 재사용하려면 조건부 요청 필요

### 캐시 검증 헤더와 조건부 요청 과정

- Last Modified와 If-Modified-Since
  - 검증 헤더의 Last Modified : 데이터가 마지막으로 수정된 시간정보를 헤더에 포함
  - 두 번째 요청의 If-Modified-Since : 캐시 유효기간이 초과되더라도 클라이언트에서 헤더를 통해 조건부 요청 가능
  - 서버의 해당 자료 최종 수정일과 비교해서 수정이 안되었다면 응답 메세지 담아서 알려줌 (304 Not Modified)
  - 서버는 body를 제외한 헤더만 전달해주고, 클라이언트는 이 헤더 정보로 캐시의 메타데이터를 갱신하며 캐시 재사용

- ETag와 If-None-Match
  - ETag : 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠
  - 서버에서 헤더에 ETag를 작성에 응답하고 클라이언트는 캐시에서 이 ETag를 저장
  - If-None-Match : 캐시시간이 초과되었다면 클라이언트는 ETag값을 검증하는 If-None-Match를 요청 헤더에 작성
  - 서버는 데이터가 수정되었는지 ETag를 통해 검증하고 수정되지 않았다면 헤더만 전송 (304 Not Modified)
  - 서버는 body를 제외한 헤더만 전달해주고, 클라이언트는 이 헤더 정보로 캐시의 메타데이터를 갱신하며 캐시 재사용

### 캐시 관련 헤더와 조건부 요청 헤더

- 캐시 지시어(directives)
  - Cache-Control : max-age (캐시 유효 기간으로 초 단위)
  - Cache-Control : no-cache (캐시 가능하지만 Origin 서버에 검증하고 사용)
  - Cache-Control : no-store (캐시를 저장하지 않기 - 메모리에서 사용하고 최대한 빨리 삭제)
  - Expires : 캐시 만료일을 날짜로 지정 (max-age를 권장하며 같이 사용시 Expires 무시)

## 프록시 캐시(Proxy Cache)
- 프록시(Proxy) : 클라이언트와 서버 사이에 대리로 통신을 수행하는 것
- 프록시 서버 : 그 중계 기능을 하는 서버로 클라이언트가 다른 네트워크와 서버 사이에 대리로 통신을 수행하는 것
- 클라이언트와 원 서버 사이 프록시 캐시 서버를 위치시켜 빠른 속도로 자료 제공
- Private 캐시 : 클라이언트의 캐시 / Public 캐시 : 프록시 서버의 캐시

### 캐시 지시어
- 설정
  - Cache-Control : public - 응답이 public 캐시에 저장되어도 됨
  - Cache-Control : private - 응답이 해당 사용자만을 위한 것이므로 private 캐시에 저장 (기본값)
  - Cache-Control : s-maxage - 프록시 캐시에만 적용되는 max-age
  - Age: 60 (HTTP 헤더) - 오리진 서버에서 응답 후 프록시 캐시 내 머문 시간 (초)

- 캐시 무효화
  - Cache-Control : no-cache
    - 데이터 캐시는 가능하지만 원 서버에 검증하기
    - max-age=0과 같은 효과
    - 원 서버와 연결 실패시 응답으로 오류가 아닌 오래된 데이터 전송 (200 OK)
  - Cache-Control : no-store
    - 데이터에 민감한 정보가 있으므로 저장하지 않고 사용 후 바로 삭제
  - Cache-Control : must-revalidate
    - 캐시 만료 후 원 서버에 검증해야 함
    - 원 서버 접근 실패시 반드시 오류 발생 (504:Gateway Timeout)
  - Pragma: no-cache (HTTP 1.0 하위 호환)

- 확실히 캐시 무효화하기 (아래 지시어 모두 넣어야 함)
  - Cache-Control : no-cache, no-store, must-revalidate
  - Pragma: no-cache

***

## CDN (Content Delivery Network)
- 콘텐츠를 빠르고 효율적으로 전달하기 위해 등장한 서비스
- 세계 곳곳의 데이터 센터에 콘텐츠를 저장해두고, 요청을 받으면 지리적으로 가까운 센터에서 콘텐츠 제공

### 1. CDN 특징
- 원본을 복사하여 저장할 여러 개의 캐시 서버로 구성
- 콘텐츠를 요청받은 경우 데이터 전달에 가장 유리한 캐시 서버에서 콘텐츠 제공
- 제공할 콘텐츠를 가지고 있는 서버 중 지리적으로 가장 가까운 곳이 우선순위 가짐

### 2. 정적 콘텐츠와 동적 콘텐츠
- 정적 콘텐츠 : 내용이 거의 변하지 않는 콘텐츠
  - HTML 파일, 동영상, 개인화되지 않은 대중적 콘텐츠 등
  - 변화가 없기 때문에 CDN 캐시 센터 저장에 적합

- 동적 콘텐츠 : 접속할 때마다 내용이 바뀌거나 사용자마자 다른 내용을 보여주는 콘텐츠
  - 위치, IP 주소, 사용시간 등 개인화된 정보
  - 공통적인 HTML 파일부분만 캐시 서버에 저장

### 3. CDN 의 이점
- DDos 공격에 대해 어느정도 대응이 가능 (한 서버가 공격 받으면 다른 서버 사용 가능)
- 로딩속도 감소로 인한 사용자 경험 향상
- 트래픽 분산으로 인해 관련 비용 절감

### 4. 네트워크 구성 방식
- Scattered 방식
  - 최대한 빠른 응답속도를 목표
  - 세계 곳곳에 비교적 낮은 성능의 데이터 센터를 구성하고 연결해 두기
  - 데이터센터의 수가 많기 때문에 데이터 센터 유지 비용 또한 높음
  - 수요가 적은 지역에 데이터 센터를 세워야 할때는 해당 방식이 유리

- Consolidated 방식
  - 데이터 센터들을 통합하여 운용하는 방식
  - 고성능의 데이터 센터들을 운용
  - 응답시간이 증가 하지만 데이터 센터의 수가 줄어듦으로 데이터 센터의 관리 및 유지 비용을 절감
  - 연결 수요가 많은 지역에 데이터 센터를 설립해야 한다면 적절한 방식
